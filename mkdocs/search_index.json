{
    "docs": [
        {
            "location": "/", 
            "text": "Couchzilla\n\n\nCouchzilla \u2013 CouchDB/Cloudant access for Julians.\n\n\n\n\nPhilosophy\n\n\nWe've tried to wrap the CouchDB API as thinly as possible, hiding the JSON and the HTTP but no  overwrought abstractions on top. That means that a CouchDB JSON document is represented as the  corresponding de-serialisation into native Julia types:\n\n\n{\n  \n_id\n: \n45c4affe6f40c7aaf0ba533f7a6601a2\n,\n  \n_rev\n: \n1-47e8deed9ccfcf8d061f7721d3ba085c\n,\n  \nitem\n: \nMalus domestica\n,\n  \nprices\n: {\n    \nFresh Mart\n: 1.59,\n    \nPrice Max\n: 5.99,\n    \nApples Express\n: 0.79\n  }\n}\n\n\n\n\nis represented as \n\n\nDict{UTF8String,Any}(\n  \n_rev\n   =\n \n1-47e8deed9ccfcf8d061f7721d3ba085c\n,\n  \nprices\n =\n Dict{UTF8String,Any}(\nFresh Mart\n=\n1.59,\nPrice Max\n=\n5.99,\nApples Express\n=\n0.79),\n  \n_id\n    =\n \n45c4affe6f40c7aaf0ba533f7a6601a2\n,\n  \nitem\n   =\n \nMalus domestica\n\n)\n\n\n\n\nAlong similar lines, Couchzilla will return CouchDB's JSON-responses simply converted as-is.\n\n\n\n\nGetting Started\n\n\nCouchzilla defines two types, \nClient\n and \nDatabase\n. \nClient\n represents an authenticated  connection to the remote CouchDB \ninstance\n. Using this you can perform database-level operations,  such as creating, listing and deleting databases. The Database immutable type represents a client that is connected to a specific database, allowing you to perform document-level operations.\n\n\nInstall the library using the normal Julia facilities \nPkg.add(\"Couchzilla\")\n.\n\n\nLet's load up the credentials from environment variables.\n\n\nusername = ENV[\nCOUCH_USER\n]\npassword = ENV[\nCOUCH_PASS\n]\nhost     = ENV[\nCOUCH_HOST_URL\n] # e.g. https://accountname.cloudant.com\n\n\n\n\nWe can now create a client connection, and use that to create a new database:\n\n\ndbname = \nmynewdb\n\nclient = Client(username, password, host)\ndb, created = createdb(client; database=dbname)\n\n\n\n\nIf the database already existed, \ncreated\n will be set to \nfalse\n on return, and \ntrue\n means that the database was created.\n\n\nWe can now add documents to the new database using \ncreatedoc\n. It returns an array of  \nDict\ns showing the \n{id, rev}\n tuples of the new documents:\n\n\nresult = createdoc(db; data=[\n    Dict(\nname\n =\n \nadam\n,    \ndata\n =\n \nhello\n),\n    Dict(\nname\n =\n \nbilly\n,   \ndata\n =\n \nworld\n),\n    Dict(\nname\n =\n \ncecilia\n, \ndata\n =\n \nauthenticate\n),\n    Dict(\nname\n =\n \ndavina\n,  \ndata\n =\n \ncloudant\n),\n    Dict(\nname\n =\n \neric\n,    \ndata\n =\n \nblobbyblobbyblobby\n)\n])\n\n\n\n\n5-element Array{Any,1}:\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-783f91178091c10cce61c326473e8849\n,\nid\n=\n3c955a5fca1e8f3b65606bc12fece4fa\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-9ecba7e9a824a6fdcfb005c454fea12e\n,\nid\n=\n3c955a5fca1e8f3b65606bc12fecf24c\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-e05530fc65101ed432c5ee457d327952\n,\nid\n=\n3c955a5fca1e8f3b65606bc12fed01e7\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-446bb325003aa6a995bde4e7c3dd513f\n,\nid\n=\n3c955a5fca1e8f3b65606bc12fed0b1e\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-e1f2181b3b4d7fa285b4516eee02d287\n,\nid\n=\n3c955a5fca1e8f3b65606bc12fed17e6\n)\n\n\n\n\nThis form of \ncreatedoc\n creates multiple documents using a single \nHTTP POST\n which is  the most efficient way of creating multiple new documents.\n\n\nWe can read a document back using \nreaddoc\n, hitting the CouchDB primary index. Note that  reading back a document you just created is normally bad practice, as it will sooner or  later fall foul of CouchDB's \neventual consistency\n  and give rise to sporadic, hard to troubleshoot errors. Having said that, let's do it  anyway, and hope for the best:\n\n\nid = result[2][\nid\n]\nreaddoc(db, id)\n\n\n\n\nDict{UTF8String,Any} with 4 entries:\n  \n_rev\n =\n \n1-9ecba7e9a824a6fdcfb005c454fea12e\n\n  \nname\n =\n \nbilly\n\n  \n_id\n  =\n \n3c955a5fca1e8f3b65606bc12fecf24c\n\n  \ndata\n =\n \nworld\n\n\n\n\nreturning the winning revision for the given \nid\n as a \nDict\n.\n\n\nConflict handling\n in CouchDB and eventual  consistency is beyond the scope of this documentation, but worth understanding fully before using  CouchDB in anger.\n\n\n\n\nQuery\n\n\nMango\n (also known as \nCloudant Query\n) is  a declarative query language inspired by \nMongoDB\n. It allows us to query the database in a (slightly) more ad-hoc fashion than using map reduce views.\n\n\nIn order to use this feature we first need to set up the necessary indexes:\n\n\ncreateindex(db; fields=[\nname\n, \ndata\n])\n\n\n\n\nDict{UTF8String,Any} with 3 entries:\n  \nname\n   =\n \nf519be04f7f80838b6a88811f75de4fb83d966dd\n\n  \nid\n     =\n \n_design/f519be04f7f80838b6a88811f75de4fb83d966dd\n\n  \nresult\n =\n \ncreated\n\n\n\n\nWe can now use this index to retrieve data:\n\n\nquery(db, q\nname=davina\n)\n\n\n\n\nCouchzilla.QueryResult([Dict{AbstractString,Any}(\n_rev\n=\n1-446bb325003aa6a995bde4e7c3dd513f\n,\nname\n=\ndavina\n,\n_id\n=\n3c955a5fca1e8f3b65606bc12fed0b1e\n,\ndata\n=\ncloudant\n)],\n)\n\n\n\n\nThe construct \nq\"...\"\n (see \n@q_str\n) is a custom string literal type which takes a simplistic DSL  expression which gets converted to the actual JSON-representation of a Mango selector. If you are familiar with \nMango selectors\n,  you can use the raw JSON expression if you prefer:\n\n\nquery(db, Selector(\n{\\\nname\\\n:{\\\n\\$eq\\\n:\\\ndavina\\\n}}\n))\n\n\n\n\nCouchzilla.QueryResult([Dict{AbstractString,Any}(\n_rev\n=\n1-446bb325003aa6a995bde4e7c3dd513f\n,\nname\n=\ndavina\n,\n_id\n=\n3c955a5fca1e8f3b65606bc12fed0b1e\n,\ndata\n=\ncloudant\n)],\n)\n\n\n\n\nThere are also coroutine versions of some of the functions that return data from views. If we had many results to process, we could use \npaged_query\n in a Julia Task:\n\n\nfor page in @task paged_query(db, q\nname=davina\n; pagesize=10)\n    # Do something with the page.docs array\nend\n\n\n\n\nThis version uses the \nlimit\n and \nskip\n parameters and issues an HTTP(S) request per page.\n\n\n\n\nViews\n\n\nA powerful feature of CouchDB are \nsecondary indexes\n,  known as \nviews\n. They are created using  a map function written most commonly in Javascript, and optionally a reduce part. For  example, to create a view on the \nname\n field, we use the following:\n\n\nmake_view(db, \nmy_ddoc\n, \nmy_view\n,\n\n\nfunction(doc) {\n  if(doc \n doc.name) {\n    emit(doc.name, 1);\n  }\n}\n)\n\n\n\n\nDict{UTF8String,Any} with 3 entries:\n  \nok\n  =\n true\n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n\n  \nid\n  =\n \n_design/my_ddoc\n\n\n\n\nTo read from this view, use the \nquery_view\n method:\n\n\nquery_view(db, \nmy_ddoc\n, \nmy_view\n; keys=[\ndavina\n, \nbilly\n])\n\n\n\n\nDict{UTF8String,Any} with 3 entries:\n  \nrows\n       =\n Any[Dict{UTF8String,Any}(\nkey\n=\ndavina\n,\nid\n=\n3c955a5fca1e8\u2026\n  \noffset\n     =\n 1\n  \ntotal_rows\n =\n 5\n\n\n\n\n\n\nUsing attachments\n\n\nCouchDB can store files alongside documents as attachments. This can be a convenient feature for many applications, but it has drawbacks, especially in terms of performance. If you find that you need to store large (say greater than a couple of meg) binary attachments, you should probably consider a dedicated, separate file store and only use CouchDB for metadata.\n\n\nTo write an attachment, use \nput_attachment\n, which expects an \n{id, rev}\n tuple referencing and existing document in the database and the path to the file holding the attachment:\n\n\ndata = createdoc(db, Dict(\nitem\n =\n \nscreenshot\n))\nresult = put_attachment(db, data[\nid\n], data[\nrev\n], \ntest.png\n, \nimage/png\n, \ndata/test.png\n)\n\n\n\n\nIn order to read the attachment, use \nget_attachment\n, which returns an IO stream:\n\n\natt = get_attachment(db, result[\nid\n], \ntest.png\n; rev=result[\nrev\n])\nopen(\ndata/fetched.png\n, \nw\n) do f\n  write(f, att)\nend\n\n\n\n\n\n\nGeospatial queries\n\n\nOne of the fancier aspects of Cloudant is its geospatial capabilities, and Couchzilla provides access to this functionality. Using this it is possible to use Cloudant to  answer questions such as \"show me all documents that fall within a given radius of a given point\". A full description of this capability is beyond the scope of this  document, but Cloudand provides rich documentation on the \nsubject\n.\n\n\nIn order to try out the geospatial stuff using Couchzilla, we first need some data.  Cloudant provides an open database that you can replicate into your own account  \nhere\n. It's a database of the locations of  reported crimes in the Boston area.\n\n\nLet's connect Couchzilla to a replica of this database, and run through the examples from Cloudant's geospatial tutorial \npage\n.  We can re-use the client from before:\n\n\ngeodb = connectdb(client; database=\ncrimes\n)\n\n\n\n\nThe database already contains the necessary geospatial indexes. Had this not been the case we could have indexed it using \ngeo_index\n.\n\n\nSo let's list the first 20 crimes within a radius of 10,000m of the Boston State House:\n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)\nresult[\nrows\n]\n\n\n\n\n200-element Array{Any,1}:\n Dict{UTF8String,Any}(\nrev\n=\n1-caa129c6e0c9e7667cd401675859da2a\n,\nid\n=\n79f14b64c57461584b152123e38fcf2b\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.06659956,42.35930134],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-e7c7eb51c49d7e5fab38b33b19542106\n,\nid\n=\n79f14b64c57461584b152123e38c548a\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.06455956,42.36115135],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-de437f29d19bb55a495693fa40975962\n,\nid\n=\n79f14b64c57461584b152123e38b22cc\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.05998657,42.36164815],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-4c4650e64d0cc0bb01e32a0b5aca2802\n,\nid\n=\n79f14b64c57461584b152123e3917804\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.05998657,42.36164815],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-e557e2555201054b924f618299cb9b64\n,\nid\n=\n79f14b64c57461584b152123e392e828\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.05998657,42.36164815],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-86261a0030776d68d98f805afec21c94\n,\nid\n=\n79f14b64c57461584b152123e38a779d\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.0587,42.3594],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-0892e7f4eb551df2453e9a11b274e190\n,\nid\n=\n79f14b64c57461584b152123e38d6b78\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.0587,42.3594],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-4ce963293c1810c3fc8fe606e9345e8e\n,\nid\n=\n79f14b64c57461584b152123e38ee226\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.0587,42.3594],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-816e850ff5ec2249993675fd568b2e9c\n,\nid\n=\n79f14b64c57461584b152123e3927629\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.0587,42.3594],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-59e512ec186a17dc3e94a3f1d7c13392\n,\nid\n=\n79f14b64c57461584b152123e392867d\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.0587,42.3594],\ntype\n=\nPoint\n))\n \u22ee\n Dict{UTF8String,Any}(\nrev\n=\n1-be45124918034417ce77adbd99d3d54f\n,\nid\n=\n79f14b64c57461584b152123e38c8ead\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.13312909,42.36337538],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-e17545f877d7fc1442abe71557ec44c8\n,\nid\n=\n79f14b64c57461584b152123e391c876\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.10727955,42.30375135],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-50e1dd9b9ad194f90a0fb4f9001d1b43\n,\nid\n=\n79f14b64c57461584b152123e3929889\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.05512457,42.28895136],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-f8407a2467b8fea166aa451994de75da\n,\nid\n=\n79f14b64c57461584b152123e38b682a\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.07728456,42.28963636],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-459aadf6156187de8c11ecce3b5f1f28\n,\nid\n=\n79f14b64c57461584b152123e38afe98\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.05007094,42.28966431],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-1d1c012db58954c6d799646e0e009728\n,\nid\n=\n79f14b64c57461584b152123e38b0d38\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.04731414,42.29018867],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-21dea1eb417bff225b4932acbe983314\n,\nid\n=\n79f14b64c57461584b152123e38c9b44\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.10965455,42.30423135],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-edd6492692311118baaa8cbb980ef1c5\n,\nid\n=\n79f14b64c57461584b152123e38d51e7\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.13410611,42.34900151],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-13144e283f47d611d62d9f11d94161be\n,\nid\n=\n79f14b64c57461584b152123e39168d7\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.13495453,42.35041635],\ntype\n=\nPoint\n))\n\n\n\n\nWe can specify a polygon for the Commercial Street corridor, which should yield only two docs:\n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  g=\nPOLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0))\n)\nresult[\nrows\n]\n\n\n\n\n2-element Array{Any,1}:\n Dict{UTF8String,Any}(\nrev\n=\n1-f0551b24741f182c5944621f87f9ac76\n,\nid\n=\n79f14b64c57461584b152123e38d6349\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.05107956,42.36510634],\ntype\n=\nPoint\n))\n Dict{UTF8String,Any}(\nrev\n=\n1-8a9f1673b2b15232bbbb956a7f3b5397\n,\nid\n=\n79f14b64c57461584b152123e3924516\n,\ngeometry\n=\nDict{UTF8String,Any}(\ncoordinates\n=\nAny[-71.05204477,42.36674199],\ntype\n=\nPoint\n))\n\n\n\n\nIf you want to delete a database, simply call \ndeletedb\n:\n\n\ndeletedb(client, dbname)\n\n\n\n\nDict{UTF8String,Any} with 1 entry:\n  \nok\n =\n true\n\n\n\n\n\n\nClient\n\n\n#\n\n\nCouchzilla.Client\n \n \nType\n.\n\n\ntype Client\n  url\n  cookies\n\n  Client(username::AbstractString, password::AbstractString, urlstr::AbstractString) = \n    cookieauth!(new(username, password, URI(urlstr)))\nend\n\n\n\n\nThe Client type represents an authenticated connection to a remote CouchDB/Cloudant instance.\n\n\n#\n\n\nCouchzilla.connectdb\n \n \nMethod\n.\n\n\ndb = connectdb(client::Client; database::AbstractString=nothing)\n\n\n\n\nReturn an immutable Database reference.\n\n\nSubsequent database-level operations will operate on the chosen database.  If you need to operate on a different database, you need to create a new  Database reference. \nconnectdb(...)\n does not check that the chosen remote  database exists.\n\n\n#\n\n\nCouchzilla.createdb\n \n \nMethod\n.\n\n\ndb, created = createdb(client::Client; database::AbstractString=nothing)\n\n\n\n\nCreate a new database on the remote end called \ndbname\n. Return an immutable  Database reference to this newly created db, and a boolean which is true if  a database was created, false if it already existed.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.dbinfo\n \n \nMethod\n.\n\n\ninfo = dbinfo(client::Client, name::AbstractString)\n\n\n\n\nReturn the meta data about the \ndbname\n database.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.listdbs\n \n \nMethod\n.\n\n\ndblist = listdbs(client::Client)\n\n\n\n\nReturn a list of all databases under the authenticated user.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.deletedb\n \n \nMethod\n.\n\n\nresult = deletedb(client::Client, name::AbstractString)\n\n\n\n\nDelete the named database.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.cookieauth!\n \n \nFunction\n.\n\n\ncookieauth!(client::Client, username, password)\n\n\n\n\nPrivate. Hits the \n_session\n endpoint to obtain a session cookie that is used to authenticate subsequent requests.\n\n\nAPI reference\n\n\n\n\nDatabase\n\n\nThe Database type represents a client connection tied to a specific database name. This is  immutable, meaning that if you need to talk to several databases you need to create one Database type for each.\n\n\n#\n\n\nCouchzilla.Database\n \n \nType\n.\n\n\nimmutable Database\n  url\n  name\n  client\n\n  Database(client::Client, name::AbstractString) =\n    new(URI(client.url.scheme, client.url.host, client.url.port, \n/$name\n), name, client)\nend\n\n\n\n\nThe Database immutable is a client connection tied to a specific remote DB. It is  normally not created directly, but via a call to \nconnectdb()\n, or \ncreatedb()\n. \n\n\nExamples\n\n\n# Connect to existing DB. Does not verify it exists.\ndb = connectdb(client; database=\nmydb\n)\n\n# Create a new db if it doesn't exist, otherwise connect \ndb, created = createdb(client; database=\nmydb\n)\n\n\n\n\n#\n\n\nCouchzilla.bulkdocs\n \n \nMethod\n.\n\n\nresult = bulkdocs(db::Database; data=[], options=Dict())\n\n\n\n\nRaw _bulk_docs.\n\n\nThis is a function primarily intended for internal use, but can be used directly to create, update or delete documents in bulk, so as to save on the HTTP overhead.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.createdoc\n \n \nFunction\n.\n\n\nresult = createdoc(db::Database; body=Dict())\n\n\n\n\nCreate a new document.\n\n\nNote that this is implemented via the \n_bulk_docs\n endpoint, rather  than a \nPOST\n to the \n/{DB}\n.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.createdoc\n \n \nMethod\n.\n\n\nresult = createdoc(db::Database; data=[Dict()])\n\n\n\n\nBulk create a set of new documents via the CouchDB \n_bulk_docs\n endpoint.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.readdoc\n \n \nMethod\n.\n\n\nresult = readdoc(db::Database, id::AbstractString; \n  rev               = \n, \n  attachments       = false, \n  att_encoding_info = false,\n  atts_since        = [],\n  conflicts         = false,\n  deleted_conflicts = false,\n  latest            = false,\n  meta              = false,\n  open_revs         = [],\n  revs              = false,\n  revs_info         = false)\n\n\n\n\nFetch a document by \nid\n.\n\n\nFor a description of the parameters, see reference below.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.updatedoc\n \n \nMethod\n.\n\n\nresult = updatedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing, body=Dict())\n\n\n\n\nUpdate an existing document, creating a new revision.\n\n\nImplemented via the _bulk_docs endpoint.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.deletedoc\n \n \nMethod\n.\n\n\nresult = deletedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing)\n\n\n\n\nDelete a document revision. Implemented via the _bulk_docs endpoint:\n\n\nAPI reference\n\n\n\n\nViews\n\n\n#\n\n\nCouchzilla.make_view\n \n \nMethod\n.\n\n\nresult = make_view(db::Database, ddoc::AbstractString, name::AbstractString, map::AbstractString; \n  reduce::AbstractString = \n)\n\n\n\n\nCreate a secondary index.\n\n\nThe \nmap\n is a string containing a map function in Javascript. Currently, \nmake_view\n  can only create a single view per design document.\n\n\nThe optional \nreduce\n parameter is a string containing either a custom Javascript reducer (best avoided for performance reasons) or the name of a built-in Erlang  reducer, e.g. \n\"_stats\"\n.\n\n\nExamples\n\n\nresult = make_view(db, \nmy_ddoc\n, \nmy_view\n, \nfunction(doc){if(doc\ndoc.name){emit(doc.name,1);}}\n)\n\n\n\n\nReturns\n\n\nReturns a \nDict(...)\n from the CouchDB response, of the type\n\n\nDict(\n  \nok\n  =\n true, \n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n,\n  \nid\n  =\n \n_design/my_ddoc\n\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.query_view\n \n \nFunction\n.\n\n\nresult = query_view(db::Database, ddoc::AbstractString, name::AbstractString;\n  descending    = false,\n  endkey        = \n,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  group         = false,\n  group_level   = 0,\n  reduce        = true,\n  stale         = false,\n  key           = \n,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      = \n)\n\n\n\n\nQuery a secondary index.\n\n\nExamples\n\n\n# Query the view for a known key subset\nresult = query_view(db, \nmy_ddoc\n, \nmy_view\n; keys=[\nadam\n, \nbilly\n])\n\n\n\n\nReturns\n\n\nDict(\n  \nrows\n =\n [\n    Dict(\nkey\n =\n \nadam\n, \nid\n =\n \n591c02fa8b8ff14dd4c0553670cc059a\n, \nvalue\n =\n 1),\n    Dict(\nkey\n =\n \nbilly\n, \nid\n =\n \n591c02fa8b8ff14dd4c0553670cc13c1\n, \nvalue\n =\n 1)\n  ],\n  \noffset\n =\n 0,\n  \ntotal_rows\n =\n 7 \n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.alldocs\n \n \nFunction\n.\n\n\nalldocs(db::Database;\n  descending    = false,\n  endkey        = \n,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  key           = \n,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      = \n)\n\n\n\n\nReturn all documents in the database by the primary index.\n\n\nThe optional parameters are:\n\n\n\n\ndescending     true/false   \u2013 lexicographical ordering of keys. Default false.\n\n\nendkey         id           \u2013 stop when \nendkey\n is reached. Optional.\n\n\nstartkey       id           \u2013 start at \nstartkey\n. Optional. \n\n\ninclude_docs   true/false   \u2013 return the document body. Default false.\n\n\nconflicts      true/false   \u2013 also return any conflicting revisions. Default false.\n\n\ninclusive_end  true/false   \u2013 if \nendkey\n is given, should this be included? Default true\n\n\nkey            id           \u2013 return only specific key. Optional.\n\n\nkeys           [id, id,...] \u2013 return only specific set of keys (will POST). Optional. \n\n\nlimit          int          \u2013 return only max \nlimit\n number of rows. Optional.\n\n\nskip           int          \u2013 skip over the first \nskip\n number of rows. Default 0.\n\n\n\n\nAPI reference\n\n\n\n\nMango/Cloudant Query\n\n\n#\n\n\nCouchzilla.Selector\n \n \nType\n.\n\n\nimmutable Selector\n  dict::Dict{AbstractString, Any}\nend\n\n\n\n\nImmutable represention of a Mango Selector used to query a Mango index.\n\n\nUsually created using the custom string literal \nq\"...\"\n (see the \n@q_str\n macro), but can be created directly from either the raw json string containing a Selector expression or a Julia \nDict(...)\n representing the same.\n\n\nExamples\n\n\nsel = q\nname = bob\n\nsel = Selector(\n{\nname\n:{\n$eq\n:\nbob\n}}\n)\nsel = Selector(Dict(\nname\n =\n Dict(\n$eq\n =\n \nbob\n)))\nsel = and([q\nname = bob\n, q\nage \n 18\n])\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.Selector\n \n \nMethod\n.\n\n\nSelector()\n\n\n\n\nThe empty Selector.\n\n\n#\n\n\nCouchzilla.Selector\n \n \nMethod\n.\n\n\nSelector(raw_json::AbstractString)\n\n\n\n\nCreate a Selector from the raw json.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.isempty\n \n \nFunction\n.\n\n\nisempty(sel::Selector)\n\n\n\n\nTrue if sel is the empty Selector.\n\n\n#\n\n\nCouchzilla.@q_str\n \n \nMacro\n.\n\n\nq\n.....\n\n\n\n\nCustom string literal for a limited Selector definition DSL.\n\n\nIt takes the form:\n\n\nfield op data\n\n\n\n\nwhere \nfield\n is a field name, op is one of \n\n\n=, !=, \n, \n=, \n, \n=, in, !in, all\n\n\n\n\nThis allows you to write things like:\n\n\nq\nname = bob\n\nq\nvalue \n 5\n\nq\noccupation in [fishmonger, pilot, welder]\n\n\n\n\nNote that the Selector DSL only covers a fraction of the full Selector syntax. It can be used with the boolean functions \nand()\n, \nor()\n etc to build up more complex Selectors, e.g.\n\n\nsel = and([q\"name = bob\", q\"age \n 18\"])\n\n\nFor more information on the actual Selector syntax, see link below.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.QueryResult\n \n \nType\n.\n\n\ntype QueryResult\n  docs::Vector{Dict{AbstractString, Any}}\n  bookmark::AbstractString \nend\n\n\n\n\nReturned by \nquery(...)\n.\n\n\nbookmark\n is only relevant when querying indexes of type \ntext\n.\n\n\n#\n\n\nCouchzilla.query\n \n \nFunction\n.\n\n\nresult = query{T\n:AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  limit                      = 0,\n  skip                       = 0,\n  bookmark                   = \n)\n\n\n\n\nQuery database (Mango/Cloudant Query).\n\n\nSee the \nSelector\n type and the associated \nq\"...\"\n custom string literal which implements a simplified DSL for writing selectors.\n\n\nExamples\n\n\nFind all documents where \"year\" is greater than 2010, returning  the fields \n_id\n, \n_rev\n, \nyear\n and \ntitle\n, sorted in ascending order  on \nyear\n. Set the page size to 10.\n\n\nresult = query(db, q\nyear \n 2010\n;\n  fields = [\n_id\n, \n_rev\n, \nyear\n, \ntitle\n],\n  sort   = [Dict(\nyear\n =\n \nasc\n)],\n  limit  = 10)\n\n\n\n\nReturns\n\n\ntype QueryResult\n\n\n\n\n\n\nAPI reference\n\n\nCloudant Query blog post\n\n\n\n\n#\n\n\nCouchzilla.paged_query\n \n \nFunction\n.\n\n\npaged_query{T\n:AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  pagesize                   = 100)\n\n\n\n\nPerform multiple HTTP requests against a JSON-type index producing the  intermediate results. This is a wrapper around \nquery()\n using the  \nskip\n and \nlimit\n parameters.\n\n\nExamples\n\n\nfor page in @task paged_query(db, q\ndata = ...\n; pagesize=10)\n  for doc in page.docs\n    # ... \n  end\nend\n\n\n\n\n#\n\n\nCouchzilla.createindex\n \n \nFunction\n.\n\n\nresult = createindex{T\n:AbstractString}(db::Database; \n  name::T       = \n,\n  ddoc::T       = \n,\n  fields        = Vector{T}(), \n  selector      = Selector(),\n  default_field = Dict{UTF8String, Any}(\nanalyzer\n =\n \nstandard\n, \nenabled\n =\n true))\n\n\n\n\nCreate a Mango index. \n\n\nAll \nkw\n parameters are optional, but note that not giving a \nfields\n argument will result in all fields being indexed which is very costly. Defaults to type \n\"json\"\n and will be assumed to be \n\"text\"\n if the data in the \nfields\n array are \nDict\ns.\n\n\nExamples\n\n\n\n\nMake a text index\n\n\n\n\nresult = createindex(db; ddoc=\nmy-ddoc\n, fields=[Dict(\nname\n=\nlastname\n, \ntype\n=\nstring\n)], \n  default_field=Dict(\nanalyzer\n =\n \ngerman\n, \nenabled\n =\n true))\n\n\n\n\n\n\nMake a json index\n\n\n\n\nresult = createindex(db; fields=[\"data\", \"data2\"])\n\n\nReturns\n\n\ncreateindex()\n returns a \nDict(...)\n version of the CouchDB response, of the type\n\n\nDict(\n  \nname\n   =\n \ne7d18f69aa0deaa1ffcdf8f705895b61515a6bf6\n,\n  \nid\n     =\n \n_design/e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6\n,\n  \nresult\n =\n \ncreated\n\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.listindexes\n \n \nMethod\n.\n\n\nresult = listindexes(db::Database)\n\n\n\n\nList all existing indexes for the database. Note that this includes indexes not created  via the \ncreateindex()\n function, such as the primary index and secondary indexes created  as map-reduce views.\n\n\nReturns\n\n\nlistindexes()\n returns a \nDict(...)\n version of the CouchDB response:\n\n\nDict(\n  \nindexes\n =\n [\n    Dict(\n      \nname\n =\n \n_all_docs\n,\n      \ndef\n  =\n Dict(\n        \nfields\n =\n [Dict(\n_id\n =\n \nasc\n)]\n      ),\n      \nddoc\n =\n nothing,\n      \ntype\n =\n \nspecial\n\n    ),\n    Dict(\n      \nddoc\n =\n \n_design/cc79a71f562af7ef36deafe511fea9a857b05bcc\n,\n      \nname\n =\n \ncc79a71f562af7ef36deafe511fea9a857b05bcc\n,\n      \ntype\n =\n \ntext\n,\n      \ndef\n  =\n Dict(\n        \nindex_array_lengths\n =\n true,\n        \nfields\n =\n [Dict(\ncust\n =\n \nstring\n), Dict(\nvalue\n =\n \nstring\n)],\n        \ndefault_field\n =\n Dict(\n          \nanalyzer\n =\n \nstandard\n, \n          \nenabled\n =\n true\n        ), \n        \nselector\n =\n Dict(),\n        \ndefault_analyzer\n =\n \nkeyword\n\n      )\n    ), \n    # ...\n  ]\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.deleteindex\n \n \nMethod\n.\n\n\nresult = deleteindex(db::Database; ddoc=\n, name=\n, indextype=\n)\n\n\n\n\nDelete a query index given its ddoc, index name and index type.\n\n\nIndextype is either \"text\" or \"json\".\n\n\nReturns\n\n\ndeleteindex()\n returns a \nDict(...)\n version of the CouchDB response:\n\n\nDict(\nok\n =\n true)\n\n\n\n\nAPI reference\n\n\n\n\nAttachments\n\n\nYou can attach files to documents in CouchDB. This can occasionally be convenient, but using attachments has performance implications, especially when combined with  replication. See Cloudant's \ndocs\n on  the subject.\n\n\n#\n\n\nCouchzilla.put_attachment\n \n \nMethod\n.\n\n\nput_attachment(db::Database, \n  id::AbstractString, \n  rev::AbstractString, \n  name::AbstractString, \n  mimetype::AbstractString, \n  file::AbstractString)\n\n\n\n\nWrite an attachment to an existing document. Attachment read from a file.\n\n\nExamples\n\n\ndoc = createdoc(db, Dict(\nitem\n =\n \nscreenshot\n))\nresult = put_attachment(db, doc[\nid\n], doc[\nrev\n], \ntest.png\n, \nimage/png\n, \ndata/test.png\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.get_attachment\n \n \nMethod\n.\n\n\nresult = get_attachment(db::Database, id::AbstractString, name::AbstractString; rev::AbstractString = \n)\n\n\n\n\nRead an attachment.\n\n\nExamples\n\n\natt = get_attachment(db, id, \ntest.png\n; rev=rev)\nopen(\ndata/fetched.png\n, \nw\n) do f\n  write(f, att)\nend\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.delete_attachment\n \n \nMethod\n.\n\n\nresult = delete_attachment(db::Database, id::AbstractString, rev::AbstractString, name::AbstractString)\n\n\n\n\nDelete an attachment.\n\n\nExamples\n\n\nresult = delete_attachment(db, id, rev, \ntest.png\n)\n\n\n\n\nAPI reference\n\n\n\n\nReplication\n\n\nUnlike e.g. \nPouchDB\n, \nCDTDatastore\n  and \nsync-android\n, \nCouchzilla\n is not a replication library  in that it does not implement a local data store. However, you have access to all replication-related endpoints provided by CouchDB. The CouchDB replication algorithm is largely undocumented, but a good \nwrite-up\n can be found  in Couchbase's repo.\n\n\n#\n\n\nCouchzilla.changes\n \n \nFunction\n.\n\n\nchanges(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  last-event-id = 0,\n  limit = 0\n  since = 0)\n\n\n\n\nQuery the CouchDB changes feed, returned as a big \nDict\n. Normal mode only. Filtering options not supported.\n\n\nExamples\n\n\nresults = changes(db; include_docs=true, since=0)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.changes_streaming\n \n \nFunction\n.\n\n\nchanges_streaming(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  last-event-id = 0,\n  limit = 0\n  since = 0)\n\n\n\n\nQuery the CouchDB changes feed, line by line. This is a co-routine.  Note that the last item produced will always  be the CouchDB \nlast_seq\n  entry.\n\n\nThis is a co-routine. Filtering options not supported.\n\n\nExamples\n\n\nfor ch in @task changes_streaming(db, limit=1)\n  println(ch)\nend\n\nDict(\n  \nseq\n=\n1-g1...gm-\n,\n  \nchanges\n=\n[Dict(\nrev\n=\n1-24213171b98945a2ed3578c926eb3651\n)], \n  \nid\n=\n37f11227ef384458b01e4afc7eed7194\n\n)\nDict(\n  \npending\n=\n213,\n  \nlast_seq\n=\n1-g1...gm-\n\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.revs_diff\n \n \nFunction\n.\n\n\nrevs_diff{T\n:AbstractString}(db::Database; data::Dict{T, Vector{T}} = Dict())\n\n\n\n\nrevs_diff\n is a component of the CouchDB replication algorithm.\n\n\nGiven set of ids and revs, it will return a potentially empty subset of ids and revs from this list which the remote end doesn't have.\n\n\nDict(\n    \n190f721ca3411be7aa9477db5f948bbb\n =\n [\n        \n3-bb72a7682290f94a985f7afac8b27137\n,\n        \n4-10265e5a26d807a3cfa459cf1a82ef2e\n,\n        \n5-067a00dff5e02add41819138abb3284d\n\n    ]\n)\n\n\n\n\nReturns\n\n\nThe returned structure is a \nDict\n where the keys are the \nid\ns of any documents where missing \nrev\ns are found. An example:\n\n\nDict(\n  \ne1132d11a43933948cb46c5e72e13659\n =\n Dict(\n    \nmissing\n =\n [\n2-1f0e2f0d841ba6b7e3d735b870ebeb8c\n],\n    \npossible_ancestors\n =\n [\n1-efda16b0115e5fcf2cfd065faee674fc\n]\n  )\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.bulk_get\n \n \nFunction\n.\n\n\nbulk_get{T\n:AbstractString}(db::Database; data::Vector{Dict{T, T}} = [])\n\n\n\n\nbulk_get\n is used as part of an optimisation of the CouchDB replication algorithm in  recent versions, allowing the replicator to request many documents with full ancestral information in a singe HTTP request.\n\n\nIt is supported in CouchDB \n= 2.0 (Cloudant \"DBNext\"), and also suported by PouchDB.\n\n\nThe \ndata\n parameter is a list of \nDict\ns with keys \nid\n and \nrev\n.\n\n\nExamples\n\n\nresult = revs_diff(db; data = [\n  Dict(\n    \nid\n  =\n \nf6b40e2fdc017e7e4ec4fa88ae3a4950\n, \n    \nrev\n =\n \n2-1f0e2f0d841ba6b7e3d735b870ebeb8c\n\n  ),\n  Dict(\n    \nid\n  =\n \n2f8b7921cbcfde79fb2ff8079cada273\n, \n    \nrev\n =\n \n1-6c3ef2ba29b6631a01ce00f80b5b4ad3\n\n  )    \n])\n\n\n\n\nReturns\n\n\nThe response format is convoluted, and seemingly undocumented for both CouchDB and Cloudant at the time of writing.\n\n\nresults\n: [\n{\n  \nid\n: \n1c43dd76fee5036c0cb360648301a710\n,\n  \ndocs\n: [\n    {\n      \nok\n: { ..doc body here...\n\n        }\n      }\n    }\n  ]\n},\n\n\n\n\nReference\n\n\n\n\nGeospatial\n\n\n#\n\n\nCouchzilla.geo_index\n \n \nFunction\n.\n\n\nresult = geo_index(db::Database, ddoc::AbstractString, name::AbstractString, index::AbstractString)\n\n\n\n\nCreate a geospatial index.\n\n\nThe \nindex\n parameter is a string containing an index function in Javascript. \n\n\nExamples\n\n\nresult = geo_index(db, \ngeodd\n, \ngeoidx\n, \n  \nfunction(doc){if(doc.geometry\ndoc.geometry.coordinates){st_index(doc.geometry);}}\n\n)\n\n\n\n\nReturns\n\n\nReturns a \nDict(...)\n from the CouchDB response, of the type\n\n\nDict(\n  \nok\n  =\n true, \n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n,\n  \nid\n  =\n \n_design/geodd\n\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.geo_index_info\n \n \nFunction\n.\n\n\nresult = geo_index_info(db::Database, ddoc::AbstractString, name::AbstractString)\n\n\n\n\nRetrieve stats for a geospatial index.\n\n\nExamples\n\n\nresult = geo_index_info(db, \ngeodd\n, \ngeoidx\n)\n\n\n\n\nReturns\n\n\nReturns a \nDict(...)\n from the CouchDB response, of the type\n\n\nDict(\n  \nname\n =\n \n_design/geodd/geoidx\n,\n  \ngeo_index\n =\n Dict(\n    \ndoc_count\n =\n 269,\n    \ndisk_size\n =\n 33416,\n    \ndata_size\n =\n 26974\n  )\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.geo_query\n \n \nFunction\n.\n\n\ngeo_query(db::Database, ddoc::AbstractString, name::AbstractString;\n  lat::Float64    = -360.0,\n  lon::Float64    = -360.0,\n  rangex::Float64 = 0.0,\n  rangey::Float64 = 0.0,\n  radius::Float64 = 0.0,\n  bbox::Vector{Float64}  = Vector{Float64}(),\n  relation::AbstractString = \nintersects\n,\n  nearest = false,\n  bookmark::AbstractString = \n,\n  format::AbstractString = \nview\n, \n  skip = 0,\n  limit = 0,\n  stale = false,\n  g::AbstractString = \n)\n\n\n\n\nQuery a geospatial index. This quickly becomes complicated. See the references below. \n\n\nThe \"g\" parameter is a string representing a \nWell Known Text\n object (\nWKT\n). It can be used to describe various geometries, such as lines and polygons. Currently supported  geometric objects are\n\n\n\n\npoint       \n\n\nlinestring\n\n\npolygon         \n\n\nmultipoint        \n\n\nmultilinestring   \n\n\nmultipolygon    \n\n\ngeometrycollection\n\n\n\n\nGeo queries can be configured to return its results in a number of different formats using the \nformat\n parameter. The accepted values are:\n\n\n\n\nlegacy              \n\n\ngeojson                 \n\n\nview (default)               \n\n\napplication/vnd.geo+json\n\n\n\n\nThe \nrelation\n parameter follows the \nDE-9IM\n spec for geometric relationships. Acceptable values are:\n\n\n\n\ncontains      \n\n\ncontains_properly\n\n\ncovered_by      \n\n\ncovers          \n\n\ncrosses         \n\n\ndisjoint        \n\n\nintersects (default)\n\n\noverlaps        \n\n\ntouches         \n\n\nwithin          \n\n\n\n\nExamples\n\n\nRadial query\n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)\n\n\n\n\nPolygon query \n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  g=\nPOLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0))\n)\n\n\n\n\nAPI reference\n\n\n\n\nUtility stuff\n\n\n#\n\n\nCouchzilla.relax\n \n \nFunction\n.\n\n\nrelax(fun, url_string; cookies=nothing, query=Dict(), headers=Dict())\n\n\n\n\nMakes an HTTP request with the relevant cookies and query strings and deserialises the response, assumed to be json.\n\n\n#\n\n\nCouchzilla.endpoint\n \n \nFunction\n.\n\n\nendpoint(uri::URI, path::AbstractString)\n\n\n\n\nAppends a path string to the URI, returning as a string.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#couchzilla", 
            "text": "Couchzilla \u2013 CouchDB/Cloudant access for Julians.", 
            "title": "Couchzilla"
        }, 
        {
            "location": "/#philosophy", 
            "text": "We've tried to wrap the CouchDB API as thinly as possible, hiding the JSON and the HTTP but no  overwrought abstractions on top. That means that a CouchDB JSON document is represented as the  corresponding de-serialisation into native Julia types:  {\n   _id :  45c4affe6f40c7aaf0ba533f7a6601a2 ,\n   _rev :  1-47e8deed9ccfcf8d061f7721d3ba085c ,\n   item :  Malus domestica ,\n   prices : {\n     Fresh Mart : 1.59,\n     Price Max : 5.99,\n     Apples Express : 0.79\n  }\n}  is represented as   Dict{UTF8String,Any}(\n   _rev    =   1-47e8deed9ccfcf8d061f7721d3ba085c ,\n   prices  =  Dict{UTF8String,Any}( Fresh Mart = 1.59, Price Max = 5.99, Apples Express = 0.79),\n   _id     =   45c4affe6f40c7aaf0ba533f7a6601a2 ,\n   item    =   Malus domestica \n)  Along similar lines, Couchzilla will return CouchDB's JSON-responses simply converted as-is.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Couchzilla defines two types,  Client  and  Database .  Client  represents an authenticated  connection to the remote CouchDB  instance . Using this you can perform database-level operations,  such as creating, listing and deleting databases. The Database immutable type represents a client that is connected to a specific database, allowing you to perform document-level operations.  Install the library using the normal Julia facilities  Pkg.add(\"Couchzilla\") .  Let's load up the credentials from environment variables.  username = ENV[ COUCH_USER ]\npassword = ENV[ COUCH_PASS ]\nhost     = ENV[ COUCH_HOST_URL ] # e.g. https://accountname.cloudant.com  We can now create a client connection, and use that to create a new database:  dbname =  mynewdb \nclient = Client(username, password, host)\ndb, created = createdb(client; database=dbname)  If the database already existed,  created  will be set to  false  on return, and  true  means that the database was created.  We can now add documents to the new database using  createdoc . It returns an array of   Dict s showing the  {id, rev}  tuples of the new documents:  result = createdoc(db; data=[\n    Dict( name  =   adam ,     data  =   hello ),\n    Dict( name  =   billy ,    data  =   world ),\n    Dict( name  =   cecilia ,  data  =   authenticate ),\n    Dict( name  =   davina ,   data  =   cloudant ),\n    Dict( name  =   eric ,     data  =   blobbyblobbyblobby )\n])  5-element Array{Any,1}:\n Dict{UTF8String,Any}( ok = true, rev = 1-783f91178091c10cce61c326473e8849 , id = 3c955a5fca1e8f3b65606bc12fece4fa )\n Dict{UTF8String,Any}( ok = true, rev = 1-9ecba7e9a824a6fdcfb005c454fea12e , id = 3c955a5fca1e8f3b65606bc12fecf24c )\n Dict{UTF8String,Any}( ok = true, rev = 1-e05530fc65101ed432c5ee457d327952 , id = 3c955a5fca1e8f3b65606bc12fed01e7 )\n Dict{UTF8String,Any}( ok = true, rev = 1-446bb325003aa6a995bde4e7c3dd513f , id = 3c955a5fca1e8f3b65606bc12fed0b1e )\n Dict{UTF8String,Any}( ok = true, rev = 1-e1f2181b3b4d7fa285b4516eee02d287 , id = 3c955a5fca1e8f3b65606bc12fed17e6 )  This form of  createdoc  creates multiple documents using a single  HTTP POST  which is  the most efficient way of creating multiple new documents.  We can read a document back using  readdoc , hitting the CouchDB primary index. Note that  reading back a document you just created is normally bad practice, as it will sooner or  later fall foul of CouchDB's  eventual consistency   and give rise to sporadic, hard to troubleshoot errors. Having said that, let's do it  anyway, and hope for the best:  id = result[2][ id ]\nreaddoc(db, id)  Dict{UTF8String,Any} with 4 entries:\n   _rev  =   1-9ecba7e9a824a6fdcfb005c454fea12e \n   name  =   billy \n   _id   =   3c955a5fca1e8f3b65606bc12fecf24c \n   data  =   world  returning the winning revision for the given  id  as a  Dict .  Conflict handling  in CouchDB and eventual  consistency is beyond the scope of this documentation, but worth understanding fully before using  CouchDB in anger.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#query", 
            "text": "Mango  (also known as  Cloudant Query ) is  a declarative query language inspired by  MongoDB . It allows us to query the database in a (slightly) more ad-hoc fashion than using map reduce views.  In order to use this feature we first need to set up the necessary indexes:  createindex(db; fields=[ name ,  data ])  Dict{UTF8String,Any} with 3 entries:\n   name    =   f519be04f7f80838b6a88811f75de4fb83d966dd \n   id      =   _design/f519be04f7f80838b6a88811f75de4fb83d966dd \n   result  =   created  We can now use this index to retrieve data:  query(db, q name=davina )  Couchzilla.QueryResult([Dict{AbstractString,Any}( _rev = 1-446bb325003aa6a995bde4e7c3dd513f , name = davina , _id = 3c955a5fca1e8f3b65606bc12fed0b1e , data = cloudant )], )  The construct  q\"...\"  (see  @q_str ) is a custom string literal type which takes a simplistic DSL  expression which gets converted to the actual JSON-representation of a Mango selector. If you are familiar with  Mango selectors ,  you can use the raw JSON expression if you prefer:  query(db, Selector( {\\ name\\ :{\\ \\$eq\\ :\\ davina\\ }} ))  Couchzilla.QueryResult([Dict{AbstractString,Any}( _rev = 1-446bb325003aa6a995bde4e7c3dd513f , name = davina , _id = 3c955a5fca1e8f3b65606bc12fed0b1e , data = cloudant )], )  There are also coroutine versions of some of the functions that return data from views. If we had many results to process, we could use  paged_query  in a Julia Task:  for page in @task paged_query(db, q name=davina ; pagesize=10)\n    # Do something with the page.docs array\nend  This version uses the  limit  and  skip  parameters and issues an HTTP(S) request per page.", 
            "title": "Query"
        }, 
        {
            "location": "/#views", 
            "text": "A powerful feature of CouchDB are  secondary indexes ,  known as  views . They are created using  a map function written most commonly in Javascript, and optionally a reduce part. For  example, to create a view on the  name  field, we use the following:  make_view(db,  my_ddoc ,  my_view , \nfunction(doc) {\n  if(doc   doc.name) {\n    emit(doc.name, 1);\n  }\n} )  Dict{UTF8String,Any} with 3 entries:\n   ok   =  true\n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc \n   id   =   _design/my_ddoc  To read from this view, use the  query_view  method:  query_view(db,  my_ddoc ,  my_view ; keys=[ davina ,  billy ])  Dict{UTF8String,Any} with 3 entries:\n   rows        =  Any[Dict{UTF8String,Any}( key = davina , id = 3c955a5fca1e8\u2026\n   offset      =  1\n   total_rows  =  5", 
            "title": "Views"
        }, 
        {
            "location": "/#using-attachments", 
            "text": "CouchDB can store files alongside documents as attachments. This can be a convenient feature for many applications, but it has drawbacks, especially in terms of performance. If you find that you need to store large (say greater than a couple of meg) binary attachments, you should probably consider a dedicated, separate file store and only use CouchDB for metadata.  To write an attachment, use  put_attachment , which expects an  {id, rev}  tuple referencing and existing document in the database and the path to the file holding the attachment:  data = createdoc(db, Dict( item  =   screenshot ))\nresult = put_attachment(db, data[ id ], data[ rev ],  test.png ,  image/png ,  data/test.png )  In order to read the attachment, use  get_attachment , which returns an IO stream:  att = get_attachment(db, result[ id ],  test.png ; rev=result[ rev ])\nopen( data/fetched.png ,  w ) do f\n  write(f, att)\nend", 
            "title": "Using attachments"
        }, 
        {
            "location": "/#geospatial-queries", 
            "text": "One of the fancier aspects of Cloudant is its geospatial capabilities, and Couchzilla provides access to this functionality. Using this it is possible to use Cloudant to  answer questions such as \"show me all documents that fall within a given radius of a given point\". A full description of this capability is beyond the scope of this  document, but Cloudand provides rich documentation on the  subject .  In order to try out the geospatial stuff using Couchzilla, we first need some data.  Cloudant provides an open database that you can replicate into your own account   here . It's a database of the locations of  reported crimes in the Boston area.  Let's connect Couchzilla to a replica of this database, and run through the examples from Cloudant's geospatial tutorial  page .  We can re-use the client from before:  geodb = connectdb(client; database= crimes )  The database already contains the necessary geospatial indexes. Had this not been the case we could have indexed it using  geo_index .  So let's list the first 20 crimes within a radius of 10,000m of the Boston State House:  result = geo_query(geodb,  geodd ,  geoidx ;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)\nresult[ rows ]  200-element Array{Any,1}:\n Dict{UTF8String,Any}( rev = 1-caa129c6e0c9e7667cd401675859da2a , id = 79f14b64c57461584b152123e38fcf2b , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.06659956,42.35930134], type = Point ))\n Dict{UTF8String,Any}( rev = 1-e7c7eb51c49d7e5fab38b33b19542106 , id = 79f14b64c57461584b152123e38c548a , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.06455956,42.36115135], type = Point ))\n Dict{UTF8String,Any}( rev = 1-de437f29d19bb55a495693fa40975962 , id = 79f14b64c57461584b152123e38b22cc , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.05998657,42.36164815], type = Point ))\n Dict{UTF8String,Any}( rev = 1-4c4650e64d0cc0bb01e32a0b5aca2802 , id = 79f14b64c57461584b152123e3917804 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.05998657,42.36164815], type = Point ))\n Dict{UTF8String,Any}( rev = 1-e557e2555201054b924f618299cb9b64 , id = 79f14b64c57461584b152123e392e828 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.05998657,42.36164815], type = Point ))\n Dict{UTF8String,Any}( rev = 1-86261a0030776d68d98f805afec21c94 , id = 79f14b64c57461584b152123e38a779d , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.0587,42.3594], type = Point ))\n Dict{UTF8String,Any}( rev = 1-0892e7f4eb551df2453e9a11b274e190 , id = 79f14b64c57461584b152123e38d6b78 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.0587,42.3594], type = Point ))\n Dict{UTF8String,Any}( rev = 1-4ce963293c1810c3fc8fe606e9345e8e , id = 79f14b64c57461584b152123e38ee226 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.0587,42.3594], type = Point ))\n Dict{UTF8String,Any}( rev = 1-816e850ff5ec2249993675fd568b2e9c , id = 79f14b64c57461584b152123e3927629 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.0587,42.3594], type = Point ))\n Dict{UTF8String,Any}( rev = 1-59e512ec186a17dc3e94a3f1d7c13392 , id = 79f14b64c57461584b152123e392867d , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.0587,42.3594], type = Point ))\n \u22ee\n Dict{UTF8String,Any}( rev = 1-be45124918034417ce77adbd99d3d54f , id = 79f14b64c57461584b152123e38c8ead , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.13312909,42.36337538], type = Point ))\n Dict{UTF8String,Any}( rev = 1-e17545f877d7fc1442abe71557ec44c8 , id = 79f14b64c57461584b152123e391c876 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.10727955,42.30375135], type = Point ))\n Dict{UTF8String,Any}( rev = 1-50e1dd9b9ad194f90a0fb4f9001d1b43 , id = 79f14b64c57461584b152123e3929889 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.05512457,42.28895136], type = Point ))\n Dict{UTF8String,Any}( rev = 1-f8407a2467b8fea166aa451994de75da , id = 79f14b64c57461584b152123e38b682a , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.07728456,42.28963636], type = Point ))\n Dict{UTF8String,Any}( rev = 1-459aadf6156187de8c11ecce3b5f1f28 , id = 79f14b64c57461584b152123e38afe98 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.05007094,42.28966431], type = Point ))\n Dict{UTF8String,Any}( rev = 1-1d1c012db58954c6d799646e0e009728 , id = 79f14b64c57461584b152123e38b0d38 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.04731414,42.29018867], type = Point ))\n Dict{UTF8String,Any}( rev = 1-21dea1eb417bff225b4932acbe983314 , id = 79f14b64c57461584b152123e38c9b44 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.10965455,42.30423135], type = Point ))\n Dict{UTF8String,Any}( rev = 1-edd6492692311118baaa8cbb980ef1c5 , id = 79f14b64c57461584b152123e38d51e7 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.13410611,42.34900151], type = Point ))\n Dict{UTF8String,Any}( rev = 1-13144e283f47d611d62d9f11d94161be , id = 79f14b64c57461584b152123e39168d7 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.13495453,42.35041635], type = Point ))  We can specify a polygon for the Commercial Street corridor, which should yield only two docs:  result = geo_query(geodb,  geodd ,  geoidx ;\n  g= POLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0)) )\nresult[ rows ]  2-element Array{Any,1}:\n Dict{UTF8String,Any}( rev = 1-f0551b24741f182c5944621f87f9ac76 , id = 79f14b64c57461584b152123e38d6349 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.05107956,42.36510634], type = Point ))\n Dict{UTF8String,Any}( rev = 1-8a9f1673b2b15232bbbb956a7f3b5397 , id = 79f14b64c57461584b152123e3924516 , geometry = Dict{UTF8String,Any}( coordinates = Any[-71.05204477,42.36674199], type = Point ))  If you want to delete a database, simply call  deletedb :  deletedb(client, dbname)  Dict{UTF8String,Any} with 1 entry:\n   ok  =  true", 
            "title": "Geospatial queries"
        }, 
        {
            "location": "/#client", 
            "text": "#  Couchzilla.Client     Type .  type Client\n  url\n  cookies\n\n  Client(username::AbstractString, password::AbstractString, urlstr::AbstractString) = \n    cookieauth!(new(username, password, URI(urlstr)))\nend  The Client type represents an authenticated connection to a remote CouchDB/Cloudant instance.  #  Couchzilla.connectdb     Method .  db = connectdb(client::Client; database::AbstractString=nothing)  Return an immutable Database reference.  Subsequent database-level operations will operate on the chosen database.  If you need to operate on a different database, you need to create a new  Database reference.  connectdb(...)  does not check that the chosen remote  database exists.  #  Couchzilla.createdb     Method .  db, created = createdb(client::Client; database::AbstractString=nothing)  Create a new database on the remote end called  dbname . Return an immutable  Database reference to this newly created db, and a boolean which is true if  a database was created, false if it already existed.  API reference  #  Couchzilla.dbinfo     Method .  info = dbinfo(client::Client, name::AbstractString)  Return the meta data about the  dbname  database.  API reference  #  Couchzilla.listdbs     Method .  dblist = listdbs(client::Client)  Return a list of all databases under the authenticated user.  API reference  #  Couchzilla.deletedb     Method .  result = deletedb(client::Client, name::AbstractString)  Delete the named database.  API reference  #  Couchzilla.cookieauth!     Function .  cookieauth!(client::Client, username, password)  Private. Hits the  _session  endpoint to obtain a session cookie that is used to authenticate subsequent requests.  API reference", 
            "title": "Client"
        }, 
        {
            "location": "/#database", 
            "text": "The Database type represents a client connection tied to a specific database name. This is  immutable, meaning that if you need to talk to several databases you need to create one Database type for each.  #  Couchzilla.Database     Type .  immutable Database\n  url\n  name\n  client\n\n  Database(client::Client, name::AbstractString) =\n    new(URI(client.url.scheme, client.url.host, client.url.port,  /$name ), name, client)\nend  The Database immutable is a client connection tied to a specific remote DB. It is  normally not created directly, but via a call to  connectdb() , or  createdb() .   Examples  # Connect to existing DB. Does not verify it exists.\ndb = connectdb(client; database= mydb )\n\n# Create a new db if it doesn't exist, otherwise connect \ndb, created = createdb(client; database= mydb )  #  Couchzilla.bulkdocs     Method .  result = bulkdocs(db::Database; data=[], options=Dict())  Raw _bulk_docs.  This is a function primarily intended for internal use, but can be used directly to create, update or delete documents in bulk, so as to save on the HTTP overhead.  API reference  #  Couchzilla.createdoc     Function .  result = createdoc(db::Database; body=Dict())  Create a new document.  Note that this is implemented via the  _bulk_docs  endpoint, rather  than a  POST  to the  /{DB} .  API reference  #  Couchzilla.createdoc     Method .  result = createdoc(db::Database; data=[Dict()])  Bulk create a set of new documents via the CouchDB  _bulk_docs  endpoint.  API reference  #  Couchzilla.readdoc     Method .  result = readdoc(db::Database, id::AbstractString; \n  rev               =  , \n  attachments       = false, \n  att_encoding_info = false,\n  atts_since        = [],\n  conflicts         = false,\n  deleted_conflicts = false,\n  latest            = false,\n  meta              = false,\n  open_revs         = [],\n  revs              = false,\n  revs_info         = false)  Fetch a document by  id .  For a description of the parameters, see reference below.  API reference  #  Couchzilla.updatedoc     Method .  result = updatedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing, body=Dict())  Update an existing document, creating a new revision.  Implemented via the _bulk_docs endpoint.  API reference  #  Couchzilla.deletedoc     Method .  result = deletedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing)  Delete a document revision. Implemented via the _bulk_docs endpoint:  API reference", 
            "title": "Database"
        }, 
        {
            "location": "/#views_1", 
            "text": "#  Couchzilla.make_view     Method .  result = make_view(db::Database, ddoc::AbstractString, name::AbstractString, map::AbstractString; \n  reduce::AbstractString =  )  Create a secondary index.  The  map  is a string containing a map function in Javascript. Currently,  make_view   can only create a single view per design document.  The optional  reduce  parameter is a string containing either a custom Javascript reducer (best avoided for performance reasons) or the name of a built-in Erlang  reducer, e.g.  \"_stats\" .  Examples  result = make_view(db,  my_ddoc ,  my_view ,  function(doc){if(doc doc.name){emit(doc.name,1);}} )  Returns  Returns a  Dict(...)  from the CouchDB response, of the type  Dict(\n   ok   =  true, \n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc ,\n   id   =   _design/my_ddoc \n)  API reference  #  Couchzilla.query_view     Function .  result = query_view(db::Database, ddoc::AbstractString, name::AbstractString;\n  descending    = false,\n  endkey        =  ,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  group         = false,\n  group_level   = 0,\n  reduce        = true,\n  stale         = false,\n  key           =  ,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      =  )  Query a secondary index.  Examples  # Query the view for a known key subset\nresult = query_view(db,  my_ddoc ,  my_view ; keys=[ adam ,  billy ])  Returns  Dict(\n   rows  =  [\n    Dict( key  =   adam ,  id  =   591c02fa8b8ff14dd4c0553670cc059a ,  value  =  1),\n    Dict( key  =   billy ,  id  =   591c02fa8b8ff14dd4c0553670cc13c1 ,  value  =  1)\n  ],\n   offset  =  0,\n   total_rows  =  7 \n)  API reference  #  Couchzilla.alldocs     Function .  alldocs(db::Database;\n  descending    = false,\n  endkey        =  ,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  key           =  ,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      =  )  Return all documents in the database by the primary index.  The optional parameters are:   descending     true/false   \u2013 lexicographical ordering of keys. Default false.  endkey         id           \u2013 stop when  endkey  is reached. Optional.  startkey       id           \u2013 start at  startkey . Optional.   include_docs   true/false   \u2013 return the document body. Default false.  conflicts      true/false   \u2013 also return any conflicting revisions. Default false.  inclusive_end  true/false   \u2013 if  endkey  is given, should this be included? Default true  key            id           \u2013 return only specific key. Optional.  keys           [id, id,...] \u2013 return only specific set of keys (will POST). Optional.   limit          int          \u2013 return only max  limit  number of rows. Optional.  skip           int          \u2013 skip over the first  skip  number of rows. Default 0.   API reference", 
            "title": "Views"
        }, 
        {
            "location": "/#mangocloudant-query", 
            "text": "#  Couchzilla.Selector     Type .  immutable Selector\n  dict::Dict{AbstractString, Any}\nend  Immutable represention of a Mango Selector used to query a Mango index.  Usually created using the custom string literal  q\"...\"  (see the  @q_str  macro), but can be created directly from either the raw json string containing a Selector expression or a Julia  Dict(...)  representing the same.  Examples  sel = q name = bob \nsel = Selector( { name :{ $eq : bob }} )\nsel = Selector(Dict( name  =  Dict( $eq  =   bob )))\nsel = and([q name = bob , q age   18 ])  API reference  #  Couchzilla.Selector     Method .  Selector()  The empty Selector.  #  Couchzilla.Selector     Method .  Selector(raw_json::AbstractString)  Create a Selector from the raw json.  API reference  #  Couchzilla.isempty     Function .  isempty(sel::Selector)  True if sel is the empty Selector.  #  Couchzilla.@q_str     Macro .  q .....  Custom string literal for a limited Selector definition DSL.  It takes the form:  field op data  where  field  is a field name, op is one of   =, !=,  ,  =,  ,  =, in, !in, all  This allows you to write things like:  q name = bob \nq value   5 \nq occupation in [fishmonger, pilot, welder]  Note that the Selector DSL only covers a fraction of the full Selector syntax. It can be used with the boolean functions  and() ,  or()  etc to build up more complex Selectors, e.g.  sel = and([q\"name = bob\", q\"age   18\"])  For more information on the actual Selector syntax, see link below.  API reference  #  Couchzilla.QueryResult     Type .  type QueryResult\n  docs::Vector{Dict{AbstractString, Any}}\n  bookmark::AbstractString \nend  Returned by  query(...) .  bookmark  is only relevant when querying indexes of type  text .  #  Couchzilla.query     Function .  result = query{T :AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  limit                      = 0,\n  skip                       = 0,\n  bookmark                   =  )  Query database (Mango/Cloudant Query).  See the  Selector  type and the associated  q\"...\"  custom string literal which implements a simplified DSL for writing selectors.  Examples  Find all documents where \"year\" is greater than 2010, returning  the fields  _id ,  _rev ,  year  and  title , sorted in ascending order  on  year . Set the page size to 10.  result = query(db, q year   2010 ;\n  fields = [ _id ,  _rev ,  year ,  title ],\n  sort   = [Dict( year  =   asc )],\n  limit  = 10)  Returns  type QueryResult   API reference  Cloudant Query blog post   #  Couchzilla.paged_query     Function .  paged_query{T :AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  pagesize                   = 100)  Perform multiple HTTP requests against a JSON-type index producing the  intermediate results. This is a wrapper around  query()  using the   skip  and  limit  parameters.  Examples  for page in @task paged_query(db, q data = ... ; pagesize=10)\n  for doc in page.docs\n    # ... \n  end\nend  #  Couchzilla.createindex     Function .  result = createindex{T :AbstractString}(db::Database; \n  name::T       =  ,\n  ddoc::T       =  ,\n  fields        = Vector{T}(), \n  selector      = Selector(),\n  default_field = Dict{UTF8String, Any}( analyzer  =   standard ,  enabled  =  true))  Create a Mango index.   All  kw  parameters are optional, but note that not giving a  fields  argument will result in all fields being indexed which is very costly. Defaults to type  \"json\"  and will be assumed to be  \"text\"  if the data in the  fields  array are  Dict s.  Examples   Make a text index   result = createindex(db; ddoc= my-ddoc , fields=[Dict( name = lastname ,  type = string )], \n  default_field=Dict( analyzer  =   german ,  enabled  =  true))   Make a json index   result = createindex(db; fields=[\"data\", \"data2\"])  Returns  createindex()  returns a  Dict(...)  version of the CouchDB response, of the type  Dict(\n   name    =   e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6 ,\n   id      =   _design/e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6 ,\n   result  =   created \n)  API reference  #  Couchzilla.listindexes     Method .  result = listindexes(db::Database)  List all existing indexes for the database. Note that this includes indexes not created  via the  createindex()  function, such as the primary index and secondary indexes created  as map-reduce views.  Returns  listindexes()  returns a  Dict(...)  version of the CouchDB response:  Dict(\n   indexes  =  [\n    Dict(\n       name  =   _all_docs ,\n       def   =  Dict(\n         fields  =  [Dict( _id  =   asc )]\n      ),\n       ddoc  =  nothing,\n       type  =   special \n    ),\n    Dict(\n       ddoc  =   _design/cc79a71f562af7ef36deafe511fea9a857b05bcc ,\n       name  =   cc79a71f562af7ef36deafe511fea9a857b05bcc ,\n       type  =   text ,\n       def   =  Dict(\n         index_array_lengths  =  true,\n         fields  =  [Dict( cust  =   string ), Dict( value  =   string )],\n         default_field  =  Dict(\n           analyzer  =   standard , \n           enabled  =  true\n        ), \n         selector  =  Dict(),\n         default_analyzer  =   keyword \n      )\n    ), \n    # ...\n  ]\n)  API reference  #  Couchzilla.deleteindex     Method .  result = deleteindex(db::Database; ddoc= , name= , indextype= )  Delete a query index given its ddoc, index name and index type.  Indextype is either \"text\" or \"json\".  Returns  deleteindex()  returns a  Dict(...)  version of the CouchDB response:  Dict( ok  =  true)  API reference", 
            "title": "Mango/Cloudant Query"
        }, 
        {
            "location": "/#attachments", 
            "text": "You can attach files to documents in CouchDB. This can occasionally be convenient, but using attachments has performance implications, especially when combined with  replication. See Cloudant's  docs  on  the subject.  #  Couchzilla.put_attachment     Method .  put_attachment(db::Database, \n  id::AbstractString, \n  rev::AbstractString, \n  name::AbstractString, \n  mimetype::AbstractString, \n  file::AbstractString)  Write an attachment to an existing document. Attachment read from a file.  Examples  doc = createdoc(db, Dict( item  =   screenshot ))\nresult = put_attachment(db, doc[ id ], doc[ rev ],  test.png ,  image/png ,  data/test.png )  API reference  #  Couchzilla.get_attachment     Method .  result = get_attachment(db::Database, id::AbstractString, name::AbstractString; rev::AbstractString =  )  Read an attachment.  Examples  att = get_attachment(db, id,  test.png ; rev=rev)\nopen( data/fetched.png ,  w ) do f\n  write(f, att)\nend  API reference  #  Couchzilla.delete_attachment     Method .  result = delete_attachment(db::Database, id::AbstractString, rev::AbstractString, name::AbstractString)  Delete an attachment.  Examples  result = delete_attachment(db, id, rev,  test.png )  API reference", 
            "title": "Attachments"
        }, 
        {
            "location": "/#replication", 
            "text": "Unlike e.g.  PouchDB ,  CDTDatastore   and  sync-android ,  Couchzilla  is not a replication library  in that it does not implement a local data store. However, you have access to all replication-related endpoints provided by CouchDB. The CouchDB replication algorithm is largely undocumented, but a good  write-up  can be found  in Couchbase's repo.  #  Couchzilla.changes     Function .  changes(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  last-event-id = 0,\n  limit = 0\n  since = 0)  Query the CouchDB changes feed, returned as a big  Dict . Normal mode only. Filtering options not supported.  Examples  results = changes(db; include_docs=true, since=0)  API reference  #  Couchzilla.changes_streaming     Function .  changes_streaming(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  last-event-id = 0,\n  limit = 0\n  since = 0)  Query the CouchDB changes feed, line by line. This is a co-routine.  Note that the last item produced will always  be the CouchDB  last_seq   entry.  This is a co-routine. Filtering options not supported.  Examples  for ch in @task changes_streaming(db, limit=1)\n  println(ch)\nend\n\nDict(\n   seq = 1-g1...gm- ,\n   changes = [Dict( rev = 1-24213171b98945a2ed3578c926eb3651 )], \n   id = 37f11227ef384458b01e4afc7eed7194 \n)\nDict(\n   pending = 213,\n   last_seq = 1-g1...gm- \n)  API reference  #  Couchzilla.revs_diff     Function .  revs_diff{T :AbstractString}(db::Database; data::Dict{T, Vector{T}} = Dict())  revs_diff  is a component of the CouchDB replication algorithm.  Given set of ids and revs, it will return a potentially empty subset of ids and revs from this list which the remote end doesn't have.  Dict(\n     190f721ca3411be7aa9477db5f948bbb  =  [\n         3-bb72a7682290f94a985f7afac8b27137 ,\n         4-10265e5a26d807a3cfa459cf1a82ef2e ,\n         5-067a00dff5e02add41819138abb3284d \n    ]\n)  Returns  The returned structure is a  Dict  where the keys are the  id s of any documents where missing  rev s are found. An example:  Dict(\n   e1132d11a43933948cb46c5e72e13659  =  Dict(\n     missing  =  [ 2-1f0e2f0d841ba6b7e3d735b870ebeb8c ],\n     possible_ancestors  =  [ 1-efda16b0115e5fcf2cfd065faee674fc ]\n  )\n)  API reference  #  Couchzilla.bulk_get     Function .  bulk_get{T :AbstractString}(db::Database; data::Vector{Dict{T, T}} = [])  bulk_get  is used as part of an optimisation of the CouchDB replication algorithm in  recent versions, allowing the replicator to request many documents with full ancestral information in a singe HTTP request.  It is supported in CouchDB  = 2.0 (Cloudant \"DBNext\"), and also suported by PouchDB.  The  data  parameter is a list of  Dict s with keys  id  and  rev .  Examples  result = revs_diff(db; data = [\n  Dict(\n     id   =   f6b40e2fdc017e7e4ec4fa88ae3a4950 , \n     rev  =   2-1f0e2f0d841ba6b7e3d735b870ebeb8c \n  ),\n  Dict(\n     id   =   2f8b7921cbcfde79fb2ff8079cada273 , \n     rev  =   1-6c3ef2ba29b6631a01ce00f80b5b4ad3 \n  )    \n])  Returns  The response format is convoluted, and seemingly undocumented for both CouchDB and Cloudant at the time of writing.  results : [\n{\n   id :  1c43dd76fee5036c0cb360648301a710 ,\n   docs : [\n    {\n       ok : { ..doc body here...\n\n        }\n      }\n    }\n  ]\n},  Reference", 
            "title": "Replication"
        }, 
        {
            "location": "/#geospatial", 
            "text": "#  Couchzilla.geo_index     Function .  result = geo_index(db::Database, ddoc::AbstractString, name::AbstractString, index::AbstractString)  Create a geospatial index.  The  index  parameter is a string containing an index function in Javascript.   Examples  result = geo_index(db,  geodd ,  geoidx , \n   function(doc){if(doc.geometry doc.geometry.coordinates){st_index(doc.geometry);}} \n)  Returns  Returns a  Dict(...)  from the CouchDB response, of the type  Dict(\n   ok   =  true, \n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc ,\n   id   =   _design/geodd \n)  API reference  #  Couchzilla.geo_index_info     Function .  result = geo_index_info(db::Database, ddoc::AbstractString, name::AbstractString)  Retrieve stats for a geospatial index.  Examples  result = geo_index_info(db,  geodd ,  geoidx )  Returns  Returns a  Dict(...)  from the CouchDB response, of the type  Dict(\n   name  =   _design/geodd/geoidx ,\n   geo_index  =  Dict(\n     doc_count  =  269,\n     disk_size  =  33416,\n     data_size  =  26974\n  )\n)  API reference  #  Couchzilla.geo_query     Function .  geo_query(db::Database, ddoc::AbstractString, name::AbstractString;\n  lat::Float64    = -360.0,\n  lon::Float64    = -360.0,\n  rangex::Float64 = 0.0,\n  rangey::Float64 = 0.0,\n  radius::Float64 = 0.0,\n  bbox::Vector{Float64}  = Vector{Float64}(),\n  relation::AbstractString =  intersects ,\n  nearest = false,\n  bookmark::AbstractString =  ,\n  format::AbstractString =  view , \n  skip = 0,\n  limit = 0,\n  stale = false,\n  g::AbstractString =  )  Query a geospatial index. This quickly becomes complicated. See the references below.   The \"g\" parameter is a string representing a  Well Known Text  object ( WKT ). It can be used to describe various geometries, such as lines and polygons. Currently supported  geometric objects are   point         linestring  polygon           multipoint          multilinestring     multipolygon      geometrycollection   Geo queries can be configured to return its results in a number of different formats using the  format  parameter. The accepted values are:   legacy                geojson                   view (default)                 application/vnd.geo+json   The  relation  parameter follows the  DE-9IM  spec for geometric relationships. Acceptable values are:   contains        contains_properly  covered_by        covers            crosses           disjoint          intersects (default)  overlaps          touches           within             Examples  Radial query  result = geo_query(geodb,  geodd ,  geoidx ;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)  Polygon query   result = geo_query(geodb,  geodd ,  geoidx ;\n  g= POLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0)) )  API reference", 
            "title": "Geospatial"
        }, 
        {
            "location": "/#utility-stuff", 
            "text": "#  Couchzilla.relax     Function .  relax(fun, url_string; cookies=nothing, query=Dict(), headers=Dict())  Makes an HTTP request with the relevant cookies and query strings and deserialises the response, assumed to be json.  #  Couchzilla.endpoint     Function .  endpoint(uri::URI, path::AbstractString)  Appends a path string to the URI, returning as a string.", 
            "title": "Utility stuff"
        }
    ]
}