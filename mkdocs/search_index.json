{
    "docs": [
        {
            "location": "/", 
            "text": "Couchzilla\n\n\nCouchzilla is a client library for CouchDB (and Cloudant).\n\n\n\n\nPhilosophy\n\n\nWe've tried to wrap the CouchDB API as thinly as possible, hiding the JSON and the HTTP but no  overwrought abstractions on top. That means that a CouchDB JSON document is represented as the  corresponding de-serialisation into native Julia types:\n\n\n{\n  \n_id\n: \n45c4affe6f40c7aaf0ba533f7a6601a2\n,\n  \n_rev\n: \n1-47e8deed9ccfcf8d061f7721d3ba085c\n,\n  \nitem\n: \nMalus domestica\n,\n  \nprices\n: {\n    \nFresh Mart\n: 1.59,\n    \nPrice Max\n: 5.99,\n    \nApples Express\n: 0.79\n  }\n}\n\n\n\n\nis represented as \n\n\nDict{UTF8String,Any}(\n  \n_rev\n   =\n \n1-47e8deed9ccfcf8d061f7721d3ba085c\n,\n  \nprices\n =\n Dict{UTF8String,Any}(\nFresh Mart\n=\n1.59,\nPrice Max\n=\n5.99,\nApples Express\n=\n0.79),\n  \n_id\n    =\n \n45c4affe6f40c7aaf0ba533f7a6601a2\n,\n  \nitem\n   =\n \nMalus domestica\n\n)\n\n\n\n\nAlong similar lines, Couchzilla will return CouchDB's JSON-responses simply converted as-is.\n\n\n\n\nGetting Started\n\n\nCouchzilla defines two types, \nClient\n and \nDatabase\n. \nClient\n represents an authenticated  connection to the remote CouchDB \ninstance\n. Using this you can perform database-level operations,  such as creating, listing and deleting databases. The Database immutable type represents a client that is connected to a specific database, allowing you to perform document-level operations.\n\n\nInstall the library using the normal Julia facilities \nPkg.add(\"Couchzilla\")\n.\n\n\nLet's load up the credentials from environment variables.\n\n\n username = ENV[\nCOUCH_USER\n]\n password = ENV[\nCOUCH_PASS\n]\n host     = ENV[\nCOUCH_HOST_URL\n] # e.g. https://accountname.cloudant.com\n\n\n\n\nWe can now create a client connection:\n\n\nclient = Client(username, password, host)\n\n\n\n\nUsing the client we can create a database:\n\n\ndb, created = createdb(client; database=\nmynewdb\n)\n\n\n\n\nIf the database already existed, \ncreated\n will be set to \nfalse\n on return, and \ntrue\n means that the database was created.\n\n\nWe can now add documents to the new database using \ncreatedoc\n:\n\n\ncreatedoc(db; data=[\n    Dict(\nname\n=\nadam\n, \ndata\n=\nhello\n),\n    Dict(\nname\n=\nbilly\n, \ndata\n=\nworld\n),\n    Dict(\nname\n=\ncecilia\n, \ndata\n=\nauthenticate\n),\n    Dict(\nname\n=\ndavina\n, \ndata\n=\ncloudant\n),\n    Dict(\nname\n=\neric\n, \ndata\n=\nblobbyblobbyblobby\n)\n])\n\n\n\n\nIt returns an array of \nDict\ns showing the \n{id, rev}\n tuples of the new documents:\n\n\n5-element Array{Any,1}:\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-783f91178091c10cce61c326473e8849\n,\nid\n=\n6163490e3753b6461cd212ec1e496b56\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-9ecba7e9a824a6fdcfb005c454fea12e\n,\nid\n=\n6163490e3753b6461cd212ec1e496fb0\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-e05530fc65101ed432c5ee457d327952\n,\nid\n=\n6163490e3753b6461cd212ec1e497092\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-446bb325003aa6a995bde4e7c3dd513f\n,\nid\n=\n6163490e3753b6461cd212ec1e497f8f\n)\n Dict{UTF8String,Any}(\nok\n=\ntrue,\nrev\n=\n1-e1f2181b3b4d7fa285b4516eee02d287\n,\nid\n=\n6163490e3753b6461cd212ec1e4984e2\n)\n\n\n\n\nThis form of \ncreatedoc\n creates multiple documents using a single \nHTTP POST\n which is  the most efficient way of creating multiple new documents.\n\n\nWe can read a document back using \nreaddoc\n, hitting the CouchDB primary index:\n\n\nreaddoc(db, \n6163490e3753b6461cd212ec1e496b56\n)\n\n\n\n\nwhich returns the winning revision for the given \nid\n as a \nDict\n:\n\n\nDict{UTF8String,Any} with 4 entries:\n  \n_id\n  =\n \n6163490e3753b6461cd212ec1e496b56\n\n  \n_rev\n =\n \n1-783f91178091c10cce61c326473e8849\n\n  \nname\n =\n \nadam\n\n  \ndata\n =\n \nhello\n\n\n\n\nIn order to use the new Mango/Cloudant Query language to interact with the database we first need to create an index:\n\n\ncreateindex(db; fields=[\nname\n, \ndata\n])\n\nDict{UTF8String,Any} with 3 entries:\n  \nname\n   =\n \nf519be04f7f80838b6a88811f75de4fb83d966dd\n\n  \nid\n     =\n \n_design/f519be04f7f80838b6a88811f75de4fb83d966dd\n\n  \nresult\n =\n \ncreated\n\n\n\n\nWe can now use this index to retrieve data:\n\n\nquery(db, q\nname=davina\n)\n\nCouchzilla.QueryResult([Dict{AbstractString,Any}(\n_rev\n=\n1-446bb325003aa6a995bde4e7c3dd513f\n,\nname\n=\ndavina\n,\n_id\n=\n6163490e3753b6461cd212ec1e497f8f\n,\ndata\n=\ncloudant\n)],\n)\n\n\n\n\nThe construct \nr\"...\"\n is a custom string literal type which takes a simplistic DSL  expression which gets converted to the actual JSON-representation of a Mango selector. If you are familiar with Mango selectors, you can use the raw JSON expression if you prefer:\n\n\nquery(db, Selector(\n{\\\nname\\\n:{\\\n\\$eq\\\n:\\\ndavina\\\n}}\n))\n\n\n\n\nYou can also create secondary indexes, known as \nviews\n. They are created using a map function written in Javascript. For example, to create a view on the \nname\n field, we could use the following:\n\n\nmake_view(db, \nmy_ddoc\n, \nmy_view\n, \n\n\nfunction(doc) {\n  if(doc \n doc.name) {\n    emit(doc.name, 1);\n  }\n}\n)\n\nDict{UTF8String,Any} with 3 entries:\n  \nok\n  =\n true\n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n\n  \nid\n  =\n \n_design/my_ddoc\n\n\n\n\nTo read from this view, use the \nquery_view\n method:\n\n\nquery_view(db, \nmy_ddoc\n, \nmy_view\n; keys=[\ndavina\n, \nbilly\n])\n\nDict{UTF8String,Any} with 3 entries:\n  \nrows\n       =\n Any[Dict{UTF8String,Any}(\nkey\n=\ndavina\n,\nid\n=\n...)\n  \noffset\n     =\n 1\n  \ntotal_rows\n =\n 5\n\n\n\n\n\n\nClient\n\n\n#\n\n\nCouchzilla.Client\n \n \nType\n.\n\n\ntype Client\n  url\n  cookies\n\n  Client(username::AbstractString, password::AbstractString, urlstr::AbstractString) = \n    cookieauth!(new(username, password, URI(urlstr)))\nend\n\n\n\n\nThe Client type represents an authenticated connection to a remote CouchDB/Cloudant instance.\n\n\n#\n\n\nCouchzilla.connectdb\n \n \nMethod\n.\n\n\ndb = connectdb(client::Client; database::AbstractString=nothing)\n\n\n\n\nReturn an immutable Database reference.\n\n\nSubsequent database-level operations will operate on the chosen database.  If you need to operate on a different database, you need to create a new  Database reference. \nconnectdb(...)\n does not check that the chosen remote  database exists.\n\n\n#\n\n\nCouchzilla.createdb\n \n \nMethod\n.\n\n\ndb, created = createdb(client::Client; database::AbstractString=nothing)\n\n\n\n\nCreate a new database on the remote end called \ndbname\n. Return an immutable  Database reference to this newly created db, and a boolean which is true if  a database was created, false if it already existed.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.dbinfo\n \n \nMethod\n.\n\n\ninfo = dbinfo(client::Client, name::AbstractString)\n\n\n\n\nReturn the meta data about the \ndbname\n database.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.listdbs\n \n \nMethod\n.\n\n\ndblist = listdbs(client::Client)\n\n\n\n\nReturn a list of all databases under the authenticated user.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.deletedb\n \n \nMethod\n.\n\n\nresult = deletedb(client::Client, name::AbstractString)\n\n\n\n\nDelete the named database.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.cookieauth!\n \n \nFunction\n.\n\n\ncookieauth!(client::Client, username, password)\n\n\n\n\nPrivate. Hits the \n_session\n endpoint to obtain a session cookie that is used to authenticate subsequent requests.\n\n\nAPI reference\n\n\n\n\nDatabase\n\n\n#\n\n\nCouchzilla.Database\n \n \nType\n.\n\n\nimmutable Database\n  url\n  name\n  client\n\n  Database(client::Client, name::AbstractString) =\n    new(URI(client.url.scheme, client.url.host, client.url.port, \n/$name\n), name, client)\nend\n\n\n\n\nThe Database immutable is a client connection tied to a specific remote DB. It is  normally not created directly, but via a call to \nconnectdb()\n, or \ncreatedb()\n. \n\n\nExamples\n\n\n# Connect to existing DB. Does not verify it exists.\ndb = connectdb(client; database=\nmydb\n)\n\n# Create a new db if it doesn't exist, otherwise connect \ndb, created = createdb(client; database=\nmydb\n)\n\n\n\n\n#\n\n\nCouchzilla.bulkdocs\n \n \nMethod\n.\n\n\nresult = bulkdocs(db::Database; data=[], options=Dict())\n\n\n\n\nRaw _bulk_docs.\n\n\nThis is a function primarily intended for internal use, but can be used directly to create, update or delete documents in bulk, so as to save on the HTTP overhead.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.createdoc\n \n \nFunction\n.\n\n\nresult = createdoc(db::Database; body=Dict())\n\n\n\n\nCreate a new document.\n\n\nNote that this is implemented via the \n_bulk_docs\n endpoint, rather  than a \nPOST\n to the \n/{DB}\n.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.createdoc\n \n \nMethod\n.\n\n\nresult = createdoc(db::Database; data=[Dict()])\n\n\n\n\nBulk create a set of new documents via the CouchDB \n_bulk_docs\n endpoint.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.readdoc\n \n \nMethod\n.\n\n\nresult = readdoc(db::Database, id::AbstractString; \n  rev               = \n, \n  attachments       = false, \n  att_encoding_info = false,\n  atts_since        = [],\n  conflicts         = false,\n  deleted_conflicts = false,\n  latest            = false,\n  meta              = false,\n  open_revs         = [],\n  revs              = false,\n  revs_info         = false)\n\n\n\n\nFetch a document by \nid\n.\n\n\nFor a description of the parameters, see reference below.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.updatedoc\n \n \nMethod\n.\n\n\nresult = updatedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing, body=Dict())\n\n\n\n\nUpdate an existing document, creating a new revision.\n\n\nImplemented via the _bulk_docs endpoint.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.deletedoc\n \n \nMethod\n.\n\n\nresult = deletedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing)\n\n\n\n\nDelete a document revision. Implemented via the _bulk_docs endpoint:\n\n\nAPI reference\n\n\n\n\nViews\n\n\n#\n\n\nCouchzilla.make_view\n \n \nMethod\n.\n\n\nresult = make_view(db::Database, ddoc::AbstractString, name::AbstractString, map::AbstractString; \n  reduce::AbstractString = \n)\n\n\n\n\nCreate a secondary index.\n\n\nThe \nmap\n is a string containing a map function in Javascript. Currently, \nmake_view\n  can only create a single view per design document.\n\n\nThe optional \nreduce\n parameter is a string containing either a custom Javascript reducer (best avoided for performance reasons) or the name of a built-in Erlang  reducer, e.g. \n\"_stats\"\n.\n\n\nExamples\n\n\nresult = make_view(db, \nmy_ddoc\n, \nmy_view\n, \nfunction(doc){if(doc\ndoc.name){emit(doc.name,1);}}\n)\n\n\n\n\nReturns\n\n\nReturns a \nDict(...)\n from the CouchDB response, of the type\n\n\nDict(\n  \nok\n  =\n true, \n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n,\n  \nid\n  =\n \n_design/my_ddoc\n\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.query_view\n \n \nFunction\n.\n\n\nresult = query_view(db::Database, ddoc::AbstractString, name::AbstractString;\n  descending    = false,\n  endkey        = \n,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  group         = false,\n  group_level   = 0,\n  reduce        = true,\n  stale         = false,\n  key           = \n,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      = \n)\n\n\n\n\nQuery a secondary index.\n\n\nExamples\n\n\n# Query the view for a known key subset\nresult = query_view(db, \nmy_ddoc\n, \nmy_view\n; keys=[\nadam\n, \nbilly\n])\n\n\n\n\nReturns\n\n\nDict(\n  \nrows\n =\n [\n    Dict(\nkey\n =\n \nadam\n, \nid\n =\n \n591c02fa8b8ff14dd4c0553670cc059a\n, \nvalue\n =\n 1),\n    Dict(\nkey\n =\n \nbilly\n, \nid\n =\n \n591c02fa8b8ff14dd4c0553670cc13c1\n, \nvalue\n =\n 1)\n  ],\n  \noffset\n =\n 0,\n  \ntotal_rows\n =\n 7 \n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.alldocs\n \n \nFunction\n.\n\n\nalldocs(db::Database;\n  descending    = false,\n  endkey        = \n,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  key           = \n,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      = \n)\n\n\n\n\nReturn all documents in the database by the primary index.\n\n\nThe optional parameters are:\n\n\n\n\ndescending     true/false   \u2013 lexicographical ordering of keys. Default false.\n\n\nendkey         id           \u2013 stop when \nendkey\n is reached. Optional.\n\n\nstartkey       id           \u2013 start at \nstartkey\n. Optional. \n\n\ninclude_docs   true/false   \u2013 return the document body. Default false.\n\n\nconflicts      true/false   \u2013 also return any conflicting revisions. Default false.\n\n\ninclusive_end  true/false   \u2013 if \nendkey\n is given, should this be included? Default true\n\n\nkey            id           \u2013 return only specific key. Optional.\n\n\nkeys           [id, id,...] \u2013 return only specific set of keys (will POST). Optional. \n\n\nlimit          int          \u2013 return only max \nlimit\n number of rows. Optional.\n\n\nskip           int          \u2013 skip over the first \nskip\n number of rows. Default 0.\n\n\n\n\nAPI reference\n\n\n\n\nMango/Cloudant Query\n\n\n#\n\n\nCouchzilla.Selector\n \n \nType\n.\n\n\nimmutable Selector\n  dict::Dict{AbstractString, Any}\nend\n\n\n\n\nImmutable represention of a Mango Selector used to query a Mango index.\n\n\nUsually created using the custom string literal \nq\"...\"\n (see the \n@q_str\n macro), but can be created directly from either the raw json string containing a Selector expression or a Julia \nDict(...)\n representing the same.\n\n\nExamples\n\n\nsel = q\nname = bob\n\nsel = Selector(\n{\nname\n:{\n$eq\n:\nbob\n}}\n)\nsel = Selector(Dict(\nname\n =\n Dict(\n$eq\n =\n \nbob\n)))\nsel = and([q\nname = bob\n, q\nage \n 18\n])\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.Selector\n \n \nMethod\n.\n\n\nSelector()\n\n\n\n\nThe empty Selector.\n\n\n#\n\n\nCouchzilla.Selector\n \n \nMethod\n.\n\n\nSelector(raw_json::AbstractString)\n\n\n\n\nCreate a Selector from the raw json.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.isempty\n \n \nFunction\n.\n\n\nisempty(sel::Selector)\n\n\n\n\nTrue if sel is the empty Selector.\n\n\n#\n\n\nCouchzilla.@q_str\n \n \nMacro\n.\n\n\nq\n.....\n\n\n\n\nCustom string literal for a limited Selector definition DSL.\n\n\nIt takes the form:\n\n\nfield op data\n\n\n\n\nwhere \nfield\n is a field name, op is one of \n\n\n=, !=, \n, \n=, \n, \n=, in, !in, all\n\n\n\n\nThis allows you to write things like:\n\n\nq\nname = bob\n\nq\nvalue \n 5\n\nq\noccupation in [fishmonger, pilot, welder]\n\n\n\n\nNote that the Selector DSL only covers a fraction of the full Selector syntax. It can be used with the boolean functions \nand()\n, \nor()\n etc to build up more complex Selectors, e.g.\n\n\nsel = and([q\"name = bob\", q\"age \n 18\"])\n\n\nFor more information on the actual Selector syntax, see link below.\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.QueryResult\n \n \nType\n.\n\n\ntype QueryResult\n  docs::Vector{Dict{AbstractString, Any}}\n  bookmark::AbstractString \nend\n\n\n\n\nReturned by \nquery(...)\n.\n\n\nbookmark\n is only relevant when querying indexes of type \ntext\n.\n\n\n#\n\n\nCouchzilla.query\n \n \nFunction\n.\n\n\nresult = query{T\n:AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  limit                      = 0,\n  skip                       = 0,\n  bookmark                   = \n)\n\n\n\n\nQuery database (Mango/Cloudant Query).\n\n\nSee the \nSelector\n type and the associated \nq\"...\"\n custom string literal which implements a simplified DSL for writing selectors.\n\n\nExamples\n\n\nFind all documents where \"year\" is greater than 2010, returning  the fields \n_id\n, \n_rev\n, \nyear\n and \ntitle\n, sorted in ascending order  on \nyear\n. Set the page size to 10.\n\n\nresult = query(db, q\nyear \n 2010\n;\n  fields = [\n_id\n, \n_rev\n, \nyear\n, \ntitle\n],\n  sort   = [Dict(\nyear\n =\n \nasc\n)],\n  limit  = 10)\n\n\n\n\nReturns\n\n\ntype QueryResult\n\n\n\n\n\n\nAPI reference\n\n\nCloudant Query blog post\n\n\n\n\n#\n\n\nCouchzilla.createindex\n \n \nFunction\n.\n\n\nresult = createindex{T\n:AbstractString}(db::Database; \n  name::T       = \n,\n  ddoc::T       = \n,\n  fields        = Vector{T}(), \n  selector      = Selector(),\n  default_field = Dict{UTF8String, Any}(\nanalyzer\n =\n \nstandard\n, \nenabled\n =\n true))\n\n\n\n\nCreate a Mango index. \n\n\nAll \nkw\n parameters are optional, but note that not giving a \nfields\n argument will result in all fields being indexed which is very costly. Defaults to type \n\"json\"\n and will be assumed to be \n\"text\"\n if the data in the \nfields\n array are \nDict\ns.\n\n\nExamples\n\n\n\n\nMake a text index\n\n\n\n\nresult = createindex(db; ddoc=\nmy-ddoc\n, fields=[Dict(\nname\n=\nlastname\n, \ntype\n=\nstring\n)], \n  default_field=Dict(\nanalyzer\n =\n \ngerman\n, \nenabled\n =\n true))\n\n\n\n\n\n\nMake a json index\n\n\n\n\nresult = createindex(db; fields=[\"data\", \"data2\"])\n\n\nReturns\n\n\ncreateindex()\n returns a \nDict(...)\n version of the CouchDB response, of the type\n\n\nDict(\n  \nname\n   =\n \ne7d18f69aa0deaa1ffcdf8f705895b61515a6bf6\n,\n  \nid\n     =\n \n_design/e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6\n,\n  \nresult\n =\n \ncreated\n\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.listindexes\n \n \nMethod\n.\n\n\nresult = listindexes(db::Database)\n\n\n\n\nList all existing indexes for the database. Note that this includes indexes not created  via the \ncreateindex()\n function, such as the primary index and secondary indexes created  as map-reduce views.\n\n\nReturns\n\n\nlistindexes()\n returns a \nDict(...)\n version of the CouchDB response:\n\n\nDict(\n  \nindexes\n =\n [\n    Dict(\n      \nname\n =\n \n_all_docs\n,\n      \ndef\n  =\n Dict(\n        \nfields\n =\n [Dict(\n_id\n =\n \nasc\n)]\n      ),\n      \nddoc\n =\n nothing,\n      \ntype\n =\n \nspecial\n\n    ),\n    Dict(\n      \nddoc\n =\n \n_design/cc79a71f562af7ef36deafe511fea9a857b05bcc\n,\n      \nname\n =\n \ncc79a71f562af7ef36deafe511fea9a857b05bcc\n,\n      \ntype\n =\n \ntext\n,\n      \ndef\n  =\n Dict(\n        \nindex_array_lengths\n =\n true,\n        \nfields\n =\n [Dict(\ncust\n =\n \nstring\n), Dict(\nvalue\n =\n \nstring\n)],\n        \ndefault_field\n =\n Dict(\n          \nanalyzer\n =\n \nstandard\n, \n          \nenabled\n =\n true\n        ), \n        \nselector\n =\n Dict(),\n        \ndefault_analyzer\n =\n \nkeyword\n\n      )\n    ), \n    # ...\n  ]\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.deleteindex\n \n \nMethod\n.\n\n\nresult = deleteindex(db::Database; ddoc=\n, name=\n, indextype=\n)\n\n\n\n\nDelete a query index given its ddoc, index name and index type.\n\n\nIndextype is either \"text\" or \"json\".\n\n\nReturns\n\n\ndeleteindex()\n returns a \nDict(...)\n version of the CouchDB response:\n\n\nDict(\nok\n =\n true)\n\n\n\n\nAPI reference\n\n\n\n\nAttachments\n\n\n#\n\n\nCouchzilla.put_attachment\n \n \nMethod\n.\n\n\nput_attachment(db::Database, \n  id::AbstractString, \n  rev::AbstractString, \n  name::AbstractString, \n  mimetype::AbstractString, \n  file::AbstractString)\n\n\n\n\nWrite an attachment to an existing document. Attachment read from a file.\n\n\nExamples\n\n\ndoc = createdoc(db, Dict(\nitem\n =\n \nscreenshot\n))\nresult = put_attachment(db, doc[\nid\n], doc[\nrev\n], \ntest.png\n, \nimage/png\n, \ndata/test.png\n)\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.get_attachment\n \n \nMethod\n.\n\n\nresult = get_attachment(db::Database, id::AbstractString, name::AbstractString; rev::AbstractString = \n)\n\n\n\n\nRead an attachment.\n\n\nExamples\n\n\natt = get_attachment(db, id, \ntest.png\n; rev=rev)\nopen(\ndata/fetched.png\n, \nw\n) do f\n  write(f, att)\nend\n\n\n\n\nAPI reference\n\n\n#\n\n\nCouchzilla.delete_attachment\n \n \nMethod\n.\n\n\nresult = delete_attachment(db::Database, id::AbstractString, rev::AbstractString, name::AbstractString)\n\n\n\n\nDelete an attachment.\n\n\nExamples\n\n\nresult = delete_attachment(db, id, rev, \ntest.png\n)\n\n\n\n\nAPI reference\n\n\n\n\nUtility stuff\n\n\n#\n\n\nCouchzilla.relax\n \n \nFunction\n.\n\n\nrelax(fun, url_string; cookies=nothing, query=Dict(), headers=Dict())\n\n\n\n\nMakes an HTTP request with the relevant cookies and query strings and deserialises the response, assumed to be json.\n\n\n#\n\n\nCouchzilla.endpoint\n \n \nFunction\n.\n\n\nendpoint(uri::URI, path::AbstractString)\n\n\n\n\nAppends a path string to the URI, returning as a string.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#couchzilla", 
            "text": "Couchzilla is a client library for CouchDB (and Cloudant).", 
            "title": "Couchzilla"
        }, 
        {
            "location": "/#philosophy", 
            "text": "We've tried to wrap the CouchDB API as thinly as possible, hiding the JSON and the HTTP but no  overwrought abstractions on top. That means that a CouchDB JSON document is represented as the  corresponding de-serialisation into native Julia types:  {\n   _id :  45c4affe6f40c7aaf0ba533f7a6601a2 ,\n   _rev :  1-47e8deed9ccfcf8d061f7721d3ba085c ,\n   item :  Malus domestica ,\n   prices : {\n     Fresh Mart : 1.59,\n     Price Max : 5.99,\n     Apples Express : 0.79\n  }\n}  is represented as   Dict{UTF8String,Any}(\n   _rev    =   1-47e8deed9ccfcf8d061f7721d3ba085c ,\n   prices  =  Dict{UTF8String,Any}( Fresh Mart = 1.59, Price Max = 5.99, Apples Express = 0.79),\n   _id     =   45c4affe6f40c7aaf0ba533f7a6601a2 ,\n   item    =   Malus domestica \n)  Along similar lines, Couchzilla will return CouchDB's JSON-responses simply converted as-is.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Couchzilla defines two types,  Client  and  Database .  Client  represents an authenticated  connection to the remote CouchDB  instance . Using this you can perform database-level operations,  such as creating, listing and deleting databases. The Database immutable type represents a client that is connected to a specific database, allowing you to perform document-level operations.  Install the library using the normal Julia facilities  Pkg.add(\"Couchzilla\") .  Let's load up the credentials from environment variables.   username = ENV[ COUCH_USER ]\n password = ENV[ COUCH_PASS ]\n host     = ENV[ COUCH_HOST_URL ] # e.g. https://accountname.cloudant.com  We can now create a client connection:  client = Client(username, password, host)  Using the client we can create a database:  db, created = createdb(client; database= mynewdb )  If the database already existed,  created  will be set to  false  on return, and  true  means that the database was created.  We can now add documents to the new database using  createdoc :  createdoc(db; data=[\n    Dict( name = adam ,  data = hello ),\n    Dict( name = billy ,  data = world ),\n    Dict( name = cecilia ,  data = authenticate ),\n    Dict( name = davina ,  data = cloudant ),\n    Dict( name = eric ,  data = blobbyblobbyblobby )\n])  It returns an array of  Dict s showing the  {id, rev}  tuples of the new documents:  5-element Array{Any,1}:\n Dict{UTF8String,Any}( ok = true, rev = 1-783f91178091c10cce61c326473e8849 , id = 6163490e3753b6461cd212ec1e496b56 )\n Dict{UTF8String,Any}( ok = true, rev = 1-9ecba7e9a824a6fdcfb005c454fea12e , id = 6163490e3753b6461cd212ec1e496fb0 )\n Dict{UTF8String,Any}( ok = true, rev = 1-e05530fc65101ed432c5ee457d327952 , id = 6163490e3753b6461cd212ec1e497092 )\n Dict{UTF8String,Any}( ok = true, rev = 1-446bb325003aa6a995bde4e7c3dd513f , id = 6163490e3753b6461cd212ec1e497f8f )\n Dict{UTF8String,Any}( ok = true, rev = 1-e1f2181b3b4d7fa285b4516eee02d287 , id = 6163490e3753b6461cd212ec1e4984e2 )  This form of  createdoc  creates multiple documents using a single  HTTP POST  which is  the most efficient way of creating multiple new documents.  We can read a document back using  readdoc , hitting the CouchDB primary index:  readdoc(db,  6163490e3753b6461cd212ec1e496b56 )  which returns the winning revision for the given  id  as a  Dict :  Dict{UTF8String,Any} with 4 entries:\n   _id   =   6163490e3753b6461cd212ec1e496b56 \n   _rev  =   1-783f91178091c10cce61c326473e8849 \n   name  =   adam \n   data  =   hello  In order to use the new Mango/Cloudant Query language to interact with the database we first need to create an index:  createindex(db; fields=[ name ,  data ])\n\nDict{UTF8String,Any} with 3 entries:\n   name    =   f519be04f7f80838b6a88811f75de4fb83d966dd \n   id      =   _design/f519be04f7f80838b6a88811f75de4fb83d966dd \n   result  =   created  We can now use this index to retrieve data:  query(db, q name=davina )\n\nCouchzilla.QueryResult([Dict{AbstractString,Any}( _rev = 1-446bb325003aa6a995bde4e7c3dd513f , name = davina , _id = 6163490e3753b6461cd212ec1e497f8f , data = cloudant )], )  The construct  r\"...\"  is a custom string literal type which takes a simplistic DSL  expression which gets converted to the actual JSON-representation of a Mango selector. If you are familiar with Mango selectors, you can use the raw JSON expression if you prefer:  query(db, Selector( {\\ name\\ :{\\ \\$eq\\ :\\ davina\\ }} ))  You can also create secondary indexes, known as  views . They are created using a map function written in Javascript. For example, to create a view on the  name  field, we could use the following:  make_view(db,  my_ddoc ,  my_view ,  \nfunction(doc) {\n  if(doc   doc.name) {\n    emit(doc.name, 1);\n  }\n} )\n\nDict{UTF8String,Any} with 3 entries:\n   ok   =  true\n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc \n   id   =   _design/my_ddoc  To read from this view, use the  query_view  method:  query_view(db,  my_ddoc ,  my_view ; keys=[ davina ,  billy ])\n\nDict{UTF8String,Any} with 3 entries:\n   rows        =  Any[Dict{UTF8String,Any}( key = davina , id = ...)\n   offset      =  1\n   total_rows  =  5", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#client", 
            "text": "#  Couchzilla.Client     Type .  type Client\n  url\n  cookies\n\n  Client(username::AbstractString, password::AbstractString, urlstr::AbstractString) = \n    cookieauth!(new(username, password, URI(urlstr)))\nend  The Client type represents an authenticated connection to a remote CouchDB/Cloudant instance.  #  Couchzilla.connectdb     Method .  db = connectdb(client::Client; database::AbstractString=nothing)  Return an immutable Database reference.  Subsequent database-level operations will operate on the chosen database.  If you need to operate on a different database, you need to create a new  Database reference.  connectdb(...)  does not check that the chosen remote  database exists.  #  Couchzilla.createdb     Method .  db, created = createdb(client::Client; database::AbstractString=nothing)  Create a new database on the remote end called  dbname . Return an immutable  Database reference to this newly created db, and a boolean which is true if  a database was created, false if it already existed.  API reference  #  Couchzilla.dbinfo     Method .  info = dbinfo(client::Client, name::AbstractString)  Return the meta data about the  dbname  database.  API reference  #  Couchzilla.listdbs     Method .  dblist = listdbs(client::Client)  Return a list of all databases under the authenticated user.  API reference  #  Couchzilla.deletedb     Method .  result = deletedb(client::Client, name::AbstractString)  Delete the named database.  API reference  #  Couchzilla.cookieauth!     Function .  cookieauth!(client::Client, username, password)  Private. Hits the  _session  endpoint to obtain a session cookie that is used to authenticate subsequent requests.  API reference", 
            "title": "Client"
        }, 
        {
            "location": "/#database", 
            "text": "#  Couchzilla.Database     Type .  immutable Database\n  url\n  name\n  client\n\n  Database(client::Client, name::AbstractString) =\n    new(URI(client.url.scheme, client.url.host, client.url.port,  /$name ), name, client)\nend  The Database immutable is a client connection tied to a specific remote DB. It is  normally not created directly, but via a call to  connectdb() , or  createdb() .   Examples  # Connect to existing DB. Does not verify it exists.\ndb = connectdb(client; database= mydb )\n\n# Create a new db if it doesn't exist, otherwise connect \ndb, created = createdb(client; database= mydb )  #  Couchzilla.bulkdocs     Method .  result = bulkdocs(db::Database; data=[], options=Dict())  Raw _bulk_docs.  This is a function primarily intended for internal use, but can be used directly to create, update or delete documents in bulk, so as to save on the HTTP overhead.  API reference  #  Couchzilla.createdoc     Function .  result = createdoc(db::Database; body=Dict())  Create a new document.  Note that this is implemented via the  _bulk_docs  endpoint, rather  than a  POST  to the  /{DB} .  API reference  #  Couchzilla.createdoc     Method .  result = createdoc(db::Database; data=[Dict()])  Bulk create a set of new documents via the CouchDB  _bulk_docs  endpoint.  API reference  #  Couchzilla.readdoc     Method .  result = readdoc(db::Database, id::AbstractString; \n  rev               =  , \n  attachments       = false, \n  att_encoding_info = false,\n  atts_since        = [],\n  conflicts         = false,\n  deleted_conflicts = false,\n  latest            = false,\n  meta              = false,\n  open_revs         = [],\n  revs              = false,\n  revs_info         = false)  Fetch a document by  id .  For a description of the parameters, see reference below.  API reference  #  Couchzilla.updatedoc     Method .  result = updatedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing, body=Dict())  Update an existing document, creating a new revision.  Implemented via the _bulk_docs endpoint.  API reference  #  Couchzilla.deletedoc     Method .  result = deletedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing)  Delete a document revision. Implemented via the _bulk_docs endpoint:  API reference", 
            "title": "Database"
        }, 
        {
            "location": "/#views", 
            "text": "#  Couchzilla.make_view     Method .  result = make_view(db::Database, ddoc::AbstractString, name::AbstractString, map::AbstractString; \n  reduce::AbstractString =  )  Create a secondary index.  The  map  is a string containing a map function in Javascript. Currently,  make_view   can only create a single view per design document.  The optional  reduce  parameter is a string containing either a custom Javascript reducer (best avoided for performance reasons) or the name of a built-in Erlang  reducer, e.g.  \"_stats\" .  Examples  result = make_view(db,  my_ddoc ,  my_view ,  function(doc){if(doc doc.name){emit(doc.name,1);}} )  Returns  Returns a  Dict(...)  from the CouchDB response, of the type  Dict(\n   ok   =  true, \n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc ,\n   id   =   _design/my_ddoc \n)  API reference  #  Couchzilla.query_view     Function .  result = query_view(db::Database, ddoc::AbstractString, name::AbstractString;\n  descending    = false,\n  endkey        =  ,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  group         = false,\n  group_level   = 0,\n  reduce        = true,\n  stale         = false,\n  key           =  ,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      =  )  Query a secondary index.  Examples  # Query the view for a known key subset\nresult = query_view(db,  my_ddoc ,  my_view ; keys=[ adam ,  billy ])  Returns  Dict(\n   rows  =  [\n    Dict( key  =   adam ,  id  =   591c02fa8b8ff14dd4c0553670cc059a ,  value  =  1),\n    Dict( key  =   billy ,  id  =   591c02fa8b8ff14dd4c0553670cc13c1 ,  value  =  1)\n  ],\n   offset  =  0,\n   total_rows  =  7 \n)  API reference  #  Couchzilla.alldocs     Function .  alldocs(db::Database;\n  descending    = false,\n  endkey        =  ,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  key           =  ,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      =  )  Return all documents in the database by the primary index.  The optional parameters are:   descending     true/false   \u2013 lexicographical ordering of keys. Default false.  endkey         id           \u2013 stop when  endkey  is reached. Optional.  startkey       id           \u2013 start at  startkey . Optional.   include_docs   true/false   \u2013 return the document body. Default false.  conflicts      true/false   \u2013 also return any conflicting revisions. Default false.  inclusive_end  true/false   \u2013 if  endkey  is given, should this be included? Default true  key            id           \u2013 return only specific key. Optional.  keys           [id, id,...] \u2013 return only specific set of keys (will POST). Optional.   limit          int          \u2013 return only max  limit  number of rows. Optional.  skip           int          \u2013 skip over the first  skip  number of rows. Default 0.   API reference", 
            "title": "Views"
        }, 
        {
            "location": "/#mangocloudant-query", 
            "text": "#  Couchzilla.Selector     Type .  immutable Selector\n  dict::Dict{AbstractString, Any}\nend  Immutable represention of a Mango Selector used to query a Mango index.  Usually created using the custom string literal  q\"...\"  (see the  @q_str  macro), but can be created directly from either the raw json string containing a Selector expression or a Julia  Dict(...)  representing the same.  Examples  sel = q name = bob \nsel = Selector( { name :{ $eq : bob }} )\nsel = Selector(Dict( name  =  Dict( $eq  =   bob )))\nsel = and([q name = bob , q age   18 ])  API reference  #  Couchzilla.Selector     Method .  Selector()  The empty Selector.  #  Couchzilla.Selector     Method .  Selector(raw_json::AbstractString)  Create a Selector from the raw json.  API reference  #  Couchzilla.isempty     Function .  isempty(sel::Selector)  True if sel is the empty Selector.  #  Couchzilla.@q_str     Macro .  q .....  Custom string literal for a limited Selector definition DSL.  It takes the form:  field op data  where  field  is a field name, op is one of   =, !=,  ,  =,  ,  =, in, !in, all  This allows you to write things like:  q name = bob \nq value   5 \nq occupation in [fishmonger, pilot, welder]  Note that the Selector DSL only covers a fraction of the full Selector syntax. It can be used with the boolean functions  and() ,  or()  etc to build up more complex Selectors, e.g.  sel = and([q\"name = bob\", q\"age   18\"])  For more information on the actual Selector syntax, see link below.  API reference  #  Couchzilla.QueryResult     Type .  type QueryResult\n  docs::Vector{Dict{AbstractString, Any}}\n  bookmark::AbstractString \nend  Returned by  query(...) .  bookmark  is only relevant when querying indexes of type  text .  #  Couchzilla.query     Function .  result = query{T :AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  limit                      = 0,\n  skip                       = 0,\n  bookmark                   =  )  Query database (Mango/Cloudant Query).  See the  Selector  type and the associated  q\"...\"  custom string literal which implements a simplified DSL for writing selectors.  Examples  Find all documents where \"year\" is greater than 2010, returning  the fields  _id ,  _rev ,  year  and  title , sorted in ascending order  on  year . Set the page size to 10.  result = query(db, q year   2010 ;\n  fields = [ _id ,  _rev ,  year ,  title ],\n  sort   = [Dict( year  =   asc )],\n  limit  = 10)  Returns  type QueryResult   API reference  Cloudant Query blog post   #  Couchzilla.createindex     Function .  result = createindex{T :AbstractString}(db::Database; \n  name::T       =  ,\n  ddoc::T       =  ,\n  fields        = Vector{T}(), \n  selector      = Selector(),\n  default_field = Dict{UTF8String, Any}( analyzer  =   standard ,  enabled  =  true))  Create a Mango index.   All  kw  parameters are optional, but note that not giving a  fields  argument will result in all fields being indexed which is very costly. Defaults to type  \"json\"  and will be assumed to be  \"text\"  if the data in the  fields  array are  Dict s.  Examples   Make a text index   result = createindex(db; ddoc= my-ddoc , fields=[Dict( name = lastname ,  type = string )], \n  default_field=Dict( analyzer  =   german ,  enabled  =  true))   Make a json index   result = createindex(db; fields=[\"data\", \"data2\"])  Returns  createindex()  returns a  Dict(...)  version of the CouchDB response, of the type  Dict(\n   name    =   e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6 ,\n   id      =   _design/e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6 ,\n   result  =   created \n)  API reference  #  Couchzilla.listindexes     Method .  result = listindexes(db::Database)  List all existing indexes for the database. Note that this includes indexes not created  via the  createindex()  function, such as the primary index and secondary indexes created  as map-reduce views.  Returns  listindexes()  returns a  Dict(...)  version of the CouchDB response:  Dict(\n   indexes  =  [\n    Dict(\n       name  =   _all_docs ,\n       def   =  Dict(\n         fields  =  [Dict( _id  =   asc )]\n      ),\n       ddoc  =  nothing,\n       type  =   special \n    ),\n    Dict(\n       ddoc  =   _design/cc79a71f562af7ef36deafe511fea9a857b05bcc ,\n       name  =   cc79a71f562af7ef36deafe511fea9a857b05bcc ,\n       type  =   text ,\n       def   =  Dict(\n         index_array_lengths  =  true,\n         fields  =  [Dict( cust  =   string ), Dict( value  =   string )],\n         default_field  =  Dict(\n           analyzer  =   standard , \n           enabled  =  true\n        ), \n         selector  =  Dict(),\n         default_analyzer  =   keyword \n      )\n    ), \n    # ...\n  ]\n)  API reference  #  Couchzilla.deleteindex     Method .  result = deleteindex(db::Database; ddoc= , name= , indextype= )  Delete a query index given its ddoc, index name and index type.  Indextype is either \"text\" or \"json\".  Returns  deleteindex()  returns a  Dict(...)  version of the CouchDB response:  Dict( ok  =  true)  API reference", 
            "title": "Mango/Cloudant Query"
        }, 
        {
            "location": "/#attachments", 
            "text": "#  Couchzilla.put_attachment     Method .  put_attachment(db::Database, \n  id::AbstractString, \n  rev::AbstractString, \n  name::AbstractString, \n  mimetype::AbstractString, \n  file::AbstractString)  Write an attachment to an existing document. Attachment read from a file.  Examples  doc = createdoc(db, Dict( item  =   screenshot ))\nresult = put_attachment(db, doc[ id ], doc[ rev ],  test.png ,  image/png ,  data/test.png )  API reference  #  Couchzilla.get_attachment     Method .  result = get_attachment(db::Database, id::AbstractString, name::AbstractString; rev::AbstractString =  )  Read an attachment.  Examples  att = get_attachment(db, id,  test.png ; rev=rev)\nopen( data/fetched.png ,  w ) do f\n  write(f, att)\nend  API reference  #  Couchzilla.delete_attachment     Method .  result = delete_attachment(db::Database, id::AbstractString, rev::AbstractString, name::AbstractString)  Delete an attachment.  Examples  result = delete_attachment(db, id, rev,  test.png )  API reference", 
            "title": "Attachments"
        }, 
        {
            "location": "/#utility-stuff", 
            "text": "#  Couchzilla.relax     Function .  relax(fun, url_string; cookies=nothing, query=Dict(), headers=Dict())  Makes an HTTP request with the relevant cookies and query strings and deserialises the response, assumed to be json.  #  Couchzilla.endpoint     Function .  endpoint(uri::URI, path::AbstractString)  Appends a path string to the URI, returning as a string.", 
            "title": "Utility stuff"
        }
    ]
}