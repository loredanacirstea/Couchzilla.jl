{
    "docs": [
        {
            "location": "/", 
            "text": "Couchzilla\n\n\nCouchzilla \u2013 CouchDB/Cloudant access for Julians.\n\n\n\n\nPhilosophy\n\n\nWe've tried to wrap the CouchDB API as thinly as possible, hiding the JSON and the HTTP but no  overwrought abstractions on top. That means that a CouchDB JSON document is represented as the  corresponding de-serialisation into native Julia types:\n\n\n{\n  \n_id\n: \n45c4affe6f40c7aaf0ba533f7a6601a2\n,\n  \n_rev\n: \n1-47e8deed9ccfcf8d061f7721d3ba085c\n,\n  \nitem\n: \nMalus domestica\n,\n  \nprices\n: {\n    \nFresh Mart\n: 1.59,\n    \nPrice Max\n: 5.99,\n    \nApples Express\n: 0.79\n  }\n}\n\n\n\n\nis represented as \n\n\nDict{UTF8String,Any}(\n  \n_rev\n   =\n \n1-47e8deed9ccfcf8d061f7721d3ba085c\n,\n  \nprices\n =\n Dict{UTF8String,Any}(\nFresh Mart\n=\n1.59,\nPrice Max\n=\n5.99,\nApples Express\n=\n0.79),\n  \n_id\n    =\n \n45c4affe6f40c7aaf0ba533f7a6601a2\n,\n  \nitem\n   =\n \nMalus domestica\n\n)\n\n\n\n\nAlong similar lines, Couchzilla will return CouchDB's JSON-responses simply converted as-is.\n\n\n\n\nCouchDB vs Cloudant\n\n\nIBM Cloudant\n offers a clustered version of CouchDB as a service. What started out as  a fork has with version 2.0 och CouchDB now largely come back togther, and Cloudant now does (nearly) all  its work directly in the Apache CouchDB repos. However, some features of Cloudant makes no sense in the CouchDB context, so there are still some differences. Couchzilla tries to cover both bases, but makes no attempt to hide Cloudant-only functionality when using CouchDB.\n\n\nThe main differences are:\n\n\n\n\nText indexes - Cloudant integrates with Lucene. CouchDB only has json indexes in its Mango implementation.\n\n\nRate capping - as Cloudant sells its service in terms of provisioned throughput capacity, Cloudant will occasionally throw a 429 error indicating that the cap has been hit.\n\n\nAPI keys \u2013 Cloudant has a separate auth system distinct from CouchDB's \n_users\n database.\n\n\nGeospatial indexes \u2013\u00a0Cloudant has sophisticated geospatial capabilities which are not present in CouchDB.\n\n\n\n\n\n\nGetting Started\n\n\nCouchzilla defines two types, \nClient\n and \nDatabase\n. \nClient\n represents an authenticated  connection to the remote CouchDB \ninstance\n. Using this you can perform database-level operations,  such as creating, listing and deleting databases. The Database immutable type represents a client that is connected to a specific database, allowing you to perform document-level operations.\n\n\nInstall the library using the normal Julia facilities \nPkg.add(\"Couchzilla\")\n.\n\n\nLet's load up the credentials from environment variables.\n\n\nusername = ENV[\nCOUCH_USER\n]\npassword = ENV[\nCOUCH_PASS\n]\nhost     = ENV[\nCOUCH_HOST_URL\n] # e.g. https://accountname.cloudant.com\n\n\n\n\nWe can now create a client connection, and use that to create a new database:\n\n\ndbname = \nmynewdb\n\nclient = Client(username, password, host)\ndb, created = createdb(client, dbname)\n\n\n\n\nIf the database already existed, \ncreated\n will be set to \nfalse\n on return, and \ntrue\n means that the database was created.\n\n\nWe can now add documents to the new database using \ncreatedoc\n. It returns an array of  \nDict\ns showing the \n{id, rev}\n tuples of the new documents:\n\n\nresult = createdoc(db, [\n    Dict(\nname\n =\n \nadam\n,    \ndata\n =\n \nhello\n),\n    Dict(\nname\n =\n \nbilly\n,   \ndata\n =\n \nworld\n),\n    Dict(\nname\n =\n \ncecilia\n, \ndata\n =\n \nauthenticate\n),\n    Dict(\nname\n =\n \ndavina\n,  \ndata\n =\n \ncloudant\n),\n    Dict(\nname\n =\n \neric\n,    \ndata\n =\n \nblobbyblobbyblobby\n)\n])\n\n\n\n\n5-element Array{Any,1}:\n Dict{String,Any}(Pair{String,Any}(\nok\n,true),Pair{String,Any}(\nrev\n,\n1-783f91178091c10cce61c326473e8849\n),Pair{String,Any}(\nid\n,\n93790b75ed6a59e5002cb0eddb78b42d\n))\n Dict{String,Any}(Pair{String,Any}(\nok\n,true),Pair{String,Any}(\nrev\n,\n1-9ecba7e9a824a6fdcfb005c454fea12e\n),Pair{String,Any}(\nid\n,\n93790b75ed6a59e5002cb0eddb78b69c\n))\n Dict{String,Any}(Pair{String,Any}(\nok\n,true),Pair{String,Any}(\nrev\n,\n1-e05530fc65101ed432c5ee457d327952\n),Pair{String,Any}(\nid\n,\n93790b75ed6a59e5002cb0eddb78c304\n))\n Dict{String,Any}(Pair{String,Any}(\nok\n,true),Pair{String,Any}(\nrev\n,\n1-446bb325003aa6a995bde4e7c3dd513f\n),Pair{String,Any}(\nid\n,\n93790b75ed6a59e5002cb0eddb78c867\n))\n Dict{String,Any}(Pair{String,Any}(\nok\n,true),Pair{String,Any}(\nrev\n,\n1-e1f2181b3b4d7fa285b4516eee02d287\n),Pair{String,Any}(\nid\n,\n93790b75ed6a59e5002cb0eddb78c8a1\n))\n\n\n\n\nThis form of \ncreatedoc\n creates multiple documents using a single \nHTTP POST\n which is  the most efficient way of creating multiple new documents.\n\n\nWe can read a document back using \nreaddoc\n, hitting the CouchDB primary index. Note that  reading back a document you just created is normally bad practice, as it will sooner or  later fall foul of CouchDB's \neventual consistency\n  and give rise to sporadic, hard to troubleshoot errors. Having said that, let's do it  anyway, and hope for the best:\n\n\nid = result[2][\nid\n]\nreaddoc(db, id)\n\n\n\n\nDict{String,Any} with 4 entries:\n  \n_rev\n =\n \n1-9ecba7e9a824a6fdcfb005c454fea12e\n\n  \nname\n =\n \nbilly\n\n  \n_id\n  =\n \n93790b75ed6a59e5002cb0eddb78b69c\n\n  \ndata\n =\n \nworld\n\n\n\n\nreturning the winning revision for the given \nid\n as a \nDict\n.\n\n\nConflict handling\n in CouchDB and eventual  consistency is beyond the scope of this documentation, but worth understanding fully before using  CouchDB in anger.\n\n\n\n\nQuery\n\n\nMango\n (also known as \nCloudant Query\n) is  a declarative query language inspired by \nMongoDB\n. It allows us to query the database in a (slightly) more ad-hoc fashion than using map reduce views.\n\n\nIn order to use this feature we first need to set up the necessary indexes:\n\n\nmango_index(db, [\nname\n, \ndata\n])\n\n\n\n\nDict{String,Any} with 3 entries:\n  \nname\n   =\n \nf519be04f7f80838b6a88811f75de4fb83d966dd\n\n  \nid\n     =\n \n_design/f519be04f7f80838b6a88811f75de4fb83d966dd\n\n  \nresult\n =\n \ncreated\n\n\n\n\nWe can now use this index to retrieve data:\n\n\nmango_query(db, q\nname=davina\n)\n\n\n\n\nCouchzilla.QueryResult(Dict{AbstractString,Any}[Dict{AbstractString,Any}(Pair{AbstractString,Any}(\n_rev\n,\n1-446bb325003aa6a995bde4e7c3dd513f\n),Pair{AbstractString,Any}(\nname\n,\ndavina\n),Pair{AbstractString,Any}(\n_id\n,\n93790b75ed6a59e5002cb0eddb78c867\n),Pair{AbstractString,Any}(\ndata\n,\ncloudant\n))],\n)\n\n\n\n\nThe construct \nq\"...\"\n (see \n@q_str\n) is a custom string literal type which takes a simplistic DSL  expression which gets converted to the actual JSON-representation of a Mango selector. If you are familiar with \nMango selectors\n,  you can use the raw JSON expression if you prefer:\n\n\nmango_query(db, Selector(\n{\\\nname\\\n:{\\\n\\$eq\\\n:\\\ndavina\\\n}}\n))\n\n\n\n\nCouchzilla.QueryResult(Dict{AbstractString,Any}[Dict{AbstractString,Any}(Pair{AbstractString,Any}(\n_rev\n,\n1-446bb325003aa6a995bde4e7c3dd513f\n),Pair{AbstractString,Any}(\nname\n,\ndavina\n),Pair{AbstractString,Any}(\n_id\n,\n93790b75ed6a59e5002cb0eddb78c867\n),Pair{AbstractString,Any}(\ndata\n,\ncloudant\n))],\n)\n\n\n\n\nThere are also coroutine versions of some of the functions that return data from views. If we had many results to process, we could use \npaged_mango_query\n in a Julia Task:\n\n\nfor page in @task paged_mango_query(db, q\nname=davina\n; pagesize=10)\n    # Do something with the page.docs array\nend\n\n\n\n\nThis version uses the \nlimit\n and \nskip\n parameters and issues an HTTP(S) request per page.\n\n\n\n\nViews\n\n\nA powerful feature of CouchDB are \nsecondary indexes\n,  known as \nviews\n. They are created using  a map function written most commonly in Javascript, and optionally a reduce part. For  example, to create a view on the \nname\n field, we use the following:\n\n\nview_index(db, \nmy_ddoc\n, \nmy_view\n,\n\n\nfunction(doc) {\n  if(doc \n doc.name) {\n    emit(doc.name, 1);\n  }\n}\n)\n\n\n\n\nDict{String,Any} with 3 entries:\n  \nok\n  =\n true\n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n\n  \nid\n  =\n \n_design/my_ddoc\n\n\n\n\nTo read from this view, use the \nview_query\n method:\n\n\nview_query(db, \nmy_ddoc\n, \nmy_view\n; keys=[\ndavina\n, \nbilly\n])\n\n\n\n\nDict{String,Any} with 3 entries:\n  \nrows\n       =\n Any[Dict{String,Any}(Pair{String,Any}(\nkey\n,\ndavina\n),Pair{St\u2026\n  \noffset\n     =\n 1\n  \ntotal_rows\n =\n 5\n\n\n\n\nCloudant has an interactive tool for trying out Mango Query which is a useful resource:\n\n\nCloudant Query demo\n\n\n\n\nUsing attachments\n\n\nCouchDB can store files alongside documents as attachments. This can be a convenient feature for many applications, but it has drawbacks, especially in terms of performance. If you find that you need to store large (say greater than a couple of meg) binary attachments, you should probably consider a dedicated, separate file store and only use CouchDB for metadata.\n\n\nTo write an attachment, use \nput_attachment\n, which expects an \n{id, rev}\n tuple referencing and existing document in the database and the path to the file holding the attachment:\n\n\ndata = createdoc(db, Dict(\nitem\n =\n \nscreenshot\n))\nresult = put_attachment(db, data[\nid\n], data[\nrev\n], \ntest.png\n, \nimage/png\n, \ndata/test.png\n)\n\n\n\n\nIn order to read the attachment, use \nget_attachment\n, which returns an IO stream:\n\n\natt = get_attachment(db, result[\nid\n], \ntest.png\n; rev=result[\nrev\n])\nopen(\ndata/fetched.png\n, \nw\n) do f\n  write(f, att)\nend\n\n\n\n\n\n\nGeospatial queries\n\n\nOne of the fancier aspects of Cloudant is its geospatial capabilities, and Couchzilla provides access to this functionality. Using this it is possible to use Cloudant to  answer questions such as \"show me all documents that fall within a given radius of a given point\". A full description of this capability is beyond the scope of this  document, but Cloudant provides rich documentation on the \nsubject\n.\n\n\nIn order to try out the geospatial stuff using Couchzilla, we first need some data.  Cloudant provides an open database that you can replicate into your own account  \nhere\n. It's a database of the locations of  reported crimes in the Boston area.\n\n\nLet's connect Couchzilla to a replica of this database, and run through the examples from Cloudant's geospatial tutorial \npage\n.  We can re-use the client from before:\n\n\ngeodb = connectdb(client, \ncrimes\n)\n\n\n\n\nThe database already contains the necessary geospatial indexes. Had this not been the case we could have indexed it using \ngeo_index\n.\n\n\nSo let's list the first 20 crimes within a radius of 10,000m of the Boston State House:\n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)\nresult[\nrows\n]\n\n\n\n\n200-element Array{Any,1}:\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-caa129c6e0c9e7667cd401675859da2a\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38fcf2b\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0666,42.3593]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-e7c7eb51c49d7e5fab38b33b19542106\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38c548a\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0646,42.3612]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-de437f29d19bb55a495693fa40975962\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38b22cc\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.06,42.3616]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-4c4650e64d0cc0bb01e32a0b5aca2802\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e3917804\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.06,42.3616]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-e557e2555201054b924f618299cb9b64\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e392e828\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.06,42.3616]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-86261a0030776d68d98f805afec21c94\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38a779d\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0587,42.3594]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-0892e7f4eb551df2453e9a11b274e190\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38d6b78\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0587,42.3594]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-4ce963293c1810c3fc8fe606e9345e8e\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38ee226\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0587,42.3594]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-816e850ff5ec2249993675fd568b2e9c\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e3927629\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0587,42.3594]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-59e512ec186a17dc3e94a3f1d7c13392\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e392867d\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0587,42.3594]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n \u22ee\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-be45124918034417ce77adbd99d3d54f\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38c8ead\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.1331,42.3634]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-e17545f877d7fc1442abe71557ec44c8\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e391c876\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.1073,42.3038]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-50e1dd9b9ad194f90a0fb4f9001d1b43\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e3929889\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0551,42.289]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-f8407a2467b8fea166aa451994de75da\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38b682a\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0773,42.2896]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-459aadf6156187de8c11ecce3b5f1f28\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38afe98\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0501,42.2897]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-1d1c012db58954c6d799646e0e009728\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38b0d38\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0473,42.2902]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-21dea1eb417bff225b4932acbe983314\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38c9b44\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.1097,42.3042]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-edd6492692311118baaa8cbb980ef1c5\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38d51e7\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.1341,42.349]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-13144e283f47d611d62d9f11d94161be\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e39168d7\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.135,42.3504]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n\n\n\n\nWe can specify a polygon for the Commercial Street corridor, which should yield only two docs:\n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  g=\nPOLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0))\n)\nresult[\nrows\n]\n\n\n\n\n2-element Array{Any,1}:\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-f0551b24741f182c5944621f87f9ac76\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e38d6349\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.0511,42.3651]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n Dict{String,Any}(Pair{String,Any}(\nrev\n,\n1-8a9f1673b2b15232bbbb956a7f3b5397\n),Pair{String,Any}(\nid\n,\n79f14b64c57461584b152123e3924516\n),Pair{String,Any}(\ngeometry\n,Dict{String,Any}(Pair{String,Any}(\ncoordinates\n,Any[-71.052,42.3667]),Pair{String,Any}(\ntype\n,\nPoint\n))))\n\n\n\n\nIf you want to delete a database, simply call \ndeletedb\n:\n\n\ndeletedb(client, dbname)\n\n\n\n\nDict{String,Any} with 1 entry:\n  \nok\n =\n true\n\n\n\n\n\n\nHandling Cloudant's rate capping\n\n\nCloudant pushes most of its stuff to upstream to \nApache CouchDB\n. However, not everything Cloudant does makes sense for CouchDB, and once such example is throughput throttling. Cloudant, currently only in its Bluemix guise, prices its service in terms of provisioned throughput capacity for lookups, writes and queries. This means that you purchase a certain max number of requests per second, bucketed by type. This is similar in spirit to how other purveyors of database services price their services (e.g. \nDynamoDB\n). \n\n\nWhen you hit capacity, Cloudant will return an error, signified by the HTTP status code 429 (\nToo many requests\n). This means that the request was not successful, and will need to be retried at a later stage. Couchzilla optionally gives you a way to deal with 429 errors:\n\n\nretry_settings!(;enabled=true, max_retries=5, delay_ms=10)\n\n\n\n\nThis will enable the retrying of requests failed with a 429. This will try a request a maximum of 5 times, with a delay of 10 ms added cumulatively, plus a little bit of noise (randomly between 1 and 10 ms). This is a module-global setting, so will apply to all \nClient\ns created within the same \nJulia\n session.\n\n\nYou can retrieve the current settings using:\n\n\nretry_settings()\n\n\n\n\nNote that this behaviour is not enabled by default, and relying on it alone on a rate-capped cluster will only help with temporary transgressions \u2013 your own code must still handle the case where the max retries are exceeded.\n\n\n\n\nUsing Cloudant's API keys for auth\n\n\nCloudant has an auth system distinct from the CouchDB traditional style based on the \n_users\n database. By using API keys you can grant and revoke a client application's access. API keys have roles attached to them, a combination of \n_admin\n, \n_reader\n, \n_writer\n, \n_replicator\n and \n_creator\n. It's not quite as straight-forward as it may seem. \n_reader\n grants read-only access. TODO\n\n\nIn order to use the API key system, you need two steps:\n\n\n\n\n\n\nCreate the key using\n\n\ndata = make_api_key(client::Client)\n2. Assign key to a database, with the appropriate roles\n\n\ncurrent = get_permissions(db)  result = set_permissions(db, current; key=data[\"key\"], roles=[\"_reader\", \"_writer\"])\n3. Create a new client connection using the new key\n\n\napi_client = Client(data[\"key\"], data[\"password\"], host)\n4. Create a database connection using the new client\n\n\napi_db = connectdb(api_client, \"dbname\")\n\n\n\n\n\n\nThere is one gotcha here that you need to be aware of. API keys are created on a central Cloudant admin cluster, and then replicated back to the one you're using. This means that running through the four steps above may occasionally fail to authenticate (step 3) for a good few minutes whilst the update percolates through. It helps to treat API keys as something to be created up front, rather than on the fly.\n\n\n\n\nClient\n\n\n#\n\n\nCouchzilla.Client\n \n \nType\n.\n\n\ntype Client\n  url\n  cookies\n\n  Client(username::AbstractString, password::AbstractString, urlstr::AbstractString; auth=true) = \n    cookieauth!(new(URI(urlstr)), username, password, auth)\nend\n\n\n\n\nThe Client type represents an authenticated connection to a remote CouchDB/Cloudant instance.\n\n\nsource\n\n\n#\n\n\nCouchzilla.connectdb\n \n \nMethod\n.\n\n\ndb = connectdb(client::Client, database::AbstractString)\n\n\n\n\nReturn an immutable Database reference.\n\n\nSubsequent database-level operations will operate on the chosen database.  If you need to operate on a different database, you need to create a new  Database reference. \nconnectdb(...)\n does not check that the chosen remote  database exists.\n\n\nsource\n\n\n#\n\n\nCouchzilla.createdb\n \n \nMethod\n.\n\n\ndb, created = createdb(client::Client, database::AbstractString)\n\n\n\n\nCreate a new database on the remote end called \ndbname\n. Return an immutable  Database reference to this newly created db, and a boolean which is true if  a database was created, false if it already existed.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.dbinfo\n \n \nMethod\n.\n\n\ninfo = dbinfo(client::Client, name::AbstractString)\n\n\n\n\nReturn the meta data about the \ndbname\n database.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.listdbs\n \n \nMethod\n.\n\n\ndblist = listdbs(client::Client)\n\n\n\n\nReturn a list of all databases under the authenticated user.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.deletedb\n \n \nMethod\n.\n\n\nresult = deletedb(client::Client, name::AbstractString)\n\n\n\n\nDelete the named database.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.cookieauth!\n \n \nFunction\n.\n\n\ncookieauth!(client::Client, username::AbstractString, password::AbstractString, auth::Bool=true)\n\n\n\n\nPrivate. Hits the \n_session\n endpoint to obtain a session cookie that is used to authenticate subsequent requests. If \nauth\n is set to  false, this does nothing.\n\n\nAPI reference\n\n\nsource\n\n\n\n\nDatabase\n\n\nThe Database type represents a client connection tied to a specific database name. This is  immutable, meaning that if you need to talk to several databases you need to create one Database type for each.\n\n\n#\n\n\nCouchzilla.Database\n \n \nType\n.\n\n\nimmutable Database\n  url\n  name\n  client\n\n  Database(client::Client, name::AbstractString) =\n    new(URI(client.url.scheme, client.url.host, client.url.port, \n/$name\n), name, client)\nend\n\n\n\n\nThe Database immutable is a client connection tied to a specific remote DB. It is  normally not created directly, but via a call to \nconnectdb()\n, or \ncreatedb()\n. \n\n\nExamples\n\n\n# Connect to existing DB. Does not verify it exists.\ndb = connectdb(client; database=\nmydb\n)\n\n# Create a new db if it doesn't exist, otherwise connect \ndb, created = createdb(client; database=\nmydb\n)\n\n\n\n\nsource\n\n\n#\n\n\nCouchzilla.bulkdocs\n \n \nMethod\n.\n\n\nresult = bulkdocs(db::Database; data=[], options=Dict())\n\n\n\n\nRaw _bulk_docs.\n\n\nThis is a function primarily intended for internal use, but can be used directly to create, update or delete documents in bulk, so as to save on the HTTP overhead.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.createdoc\n \n \nMethod\n.\n\n\nresult = createdoc(db::Database, body::Dict)\n\n\n\n\nCreate one new document.\n\n\nNote that this is implemented via the \n_bulk_docs\n endpoint, rather  than a \nPOST\n to the \n/{DB}\n.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.createdoc\n \n \nMethod\n.\n\n\nresult = createdoc(db::Database, data::AbstractArray\n\n\n\n\nBulk create a set of new documents via the CouchDB \n_bulk_docs\n endpoint.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.readdoc\n \n \nMethod\n.\n\n\nresult = readdoc(db::Database, id::AbstractString; \n  rev               = \n, \n  attachments       = false, \n  att_encoding_info = false,\n  atts_since        = [],\n  open_revs         = [],\n  conflicts         = false,\n  deleted_conflicts = false,\n  latest            = false,\n  meta              = false,\n  revs              = false,\n  revs_info         = false)\n\n\n\n\nFetch a document by \nid\n.\n\n\nFor a description of the parameters, see reference below. To use the \nopen_revs\n parameter as \nall\n, use\n\n\nresult = readdoc(db, id; open_revs=[\nall\n])\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.updatedoc\n \n \nMethod\n.\n\n\nresult = updatedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing, body=Dict())\n\n\n\n\nUpdate an existing document, creating a new revision.\n\n\nImplemented via the _bulk_docs endpoint.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.deletedoc\n \n \nMethod\n.\n\n\nresult = deletedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing)\n\n\n\n\nDelete a document revision. Implemented via the _bulk_docs endpoint:\n\n\nAPI reference\n\n\nsource\n\n\n\n\nViews\n\n\n#\n\n\nCouchzilla.view_index\n \n \nMethod\n.\n\n\nresult = view_index(db::Database, ddoc::AbstractString, name::AbstractString, map::AbstractString; \n  reduce::AbstractString = \n)\n\n\n\n\nCreate a secondary index.\n\n\nThe \nmap\n is a string containing a map function in Javascript. Currently, \nmake_view\n  can only create a single view per design document.\n\n\nThe optional \nreduce\n parameter is a string containing either a custom Javascript reducer (best avoided for performance reasons) or the name of a built-in Erlang  reducer, e.g. \n\"_stats\"\n.\n\n\nExamples\n\n\nresult = view_index(db, \nmy_ddoc\n, \nmy_view\n, \nfunction(doc){if(doc\ndoc.name){emit(doc.name,1);}}\n)\n\n\n\n\nReturns\n\n\nReturns a \nDict(...)\n from the CouchDB response, of the type\n\n\nDict(\n  \nok\n  =\n true, \n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n,\n  \nid\n  =\n \n_design/my_ddoc\n\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.view_query\n \n \nFunction\n.\n\n\nresult = view_query(db::Database, ddoc::AbstractString, name::AbstractString;\n  descending    = false,\n  endkey        = \n,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  group         = false,\n  group_level   = 0,\n  reduce        = true,\n  key           = \n,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      = \n)\n\n\n\n\nQuery a secondary index.\n\n\nExamples\n\n\n# Query the view for a known key subset\nresult = view_query(db, \nmy_ddoc\n, \nmy_view\n; keys=[\nadam\n, \nbilly\n])\n\n\n\n\nReturns\n\n\nDict(\n  \nrows\n =\n [\n    Dict(\nkey\n =\n \nadam\n, \nid\n =\n \n591c02fa8b8ff14dd4c0553670cc059a\n, \nvalue\n =\n 1),\n    Dict(\nkey\n =\n \nbilly\n, \nid\n =\n \n591c02fa8b8ff14dd4c0553670cc13c1\n, \nvalue\n =\n 1)\n  ],\n  \noffset\n =\n 0,\n  \ntotal_rows\n =\n 7 \n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.alldocs\n \n \nFunction\n.\n\n\nalldocs(db::Database;\n  descending    = false,\n  endkey        = \n,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  key           = \n,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      = \n)\n\n\n\n\nReturn all documents in the database by the primary index.\n\n\nThe optional parameters are:\n\n\n\n\ndescending     true/false   \u2013 lexicographical ordering of keys. Default false.\n\n\nendkey         id           \u2013 stop when \nendkey\n is reached. Optional.\n\n\nstartkey       id           \u2013 start at \nstartkey\n. Optional.\n\n\ninclude_docs   true/false   \u2013 return the document body. Default false.\n\n\nconflicts      true/false   \u2013 also return any conflicting revisions. Default false.\n\n\ninclusive_end  true/false   \u2013 if \nendkey\n is given, should this be included? Default true\n\n\nkey            id           \u2013 return only specific key. Optional.\n\n\nkeys           [id, id,...] \u2013 return only specific set of keys (will POST). Optional.\n\n\nlimit          int          \u2013 return only max \nlimit\n number of rows. Optional.\n\n\nskip           int          \u2013 skip over the first \nskip\n number of rows. Default 0.\n\n\n\n\nAPI reference\n\n\nsource\n\n\n\n\nMango/Cloudant Query\n\n\n#\n\n\nCouchzilla.Selector\n \n \nType\n.\n\n\nimmutable Selector\n  dict::Dict{AbstractString, Any}\nend\n\n\n\n\nImmutable represention of a Mango Selector used to query a Mango index.\n\n\nUsually created using the custom string literal \nq\"...\"\n (see the \n@q_str\n macro), but can be created directly from either the raw json string containing a Selector expression or a Julia \nDict(...)\n representing the same.\n\n\nExamples\n\n\nsel = q\nname = bob\n\nsel = Selector(\n{\nname\n:{\n$eq\n:\nbob\n}}\n)\nsel = Selector(Dict(\nname\n =\n Dict(\n$eq\n =\n \nbob\n)))\nsel = and([q\nname = bob\n, q\nage \n 18\n])\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.Selector\n \n \nMethod\n.\n\n\nSelector()\n\n\n\n\nThe empty Selector.\n\n\nsource\n\n\n#\n\n\nCouchzilla.Selector\n \n \nMethod\n.\n\n\nSelector(raw_json::AbstractString)\n\n\n\n\nCreate a Selector from the raw json.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nBase.isempty\n \n \nFunction\n.\n\n\nisempty(sel::Selector)\n\n\n\n\nTrue if sel is the empty Selector.\n\n\nsource\n\n\n#\n\n\nCouchzilla.@q_str\n \n \nMacro\n.\n\n\nq\n.....\n\n\n\n\nCustom string literal for a limited Selector definition DSL.\n\n\nIt takes the form:\n\n\nfield op data\n\n\n\n\nwhere \nfield\n is a field name, op is one of \n\n\n=, !=, \n, \n=, \n, \n=, in, !in, all\n\n\n\n\nThis allows you to write things like:\n\n\nq\nname = bob\n\nq\nvalue \n 5\n\nq\noccupation in [fishmonger, pilot, welder]\n\n\n\n\nNote that the Selector DSL only covers a fraction of the full Selector syntax. It can be used with the boolean functions \nand()\n, \nor()\n etc to build up more complex Selectors, e.g.\n\n\nsel = and([q\"name = bob\", q\"age \n 18\"])\n\n\nFor more information on the actual Selector syntax, see link below.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.QueryResult\n \n \nType\n.\n\n\ntype QueryResult\n  docs::Vector{Dict{AbstractString, Any}}\n  bookmark::AbstractString \nend\n\n\n\n\nReturned by \nquery(...)\n.\n\n\nbookmark\n is only relevant when querying indexes of type \ntext\n.\n\n\nsource\n\n\n#\n\n\nCouchzilla.mango_query\n \n \nFunction\n.\n\n\nresult = mango_query{T\n:AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  limit                      = 0,\n  skip                       = 0,\n  bookmark                   = \n)\n\n\n\n\nQuery database (Mango/Cloudant Query).\n\n\nSee the \nSelector\n type and the associated \nq\"...\"\n custom string literal which implements a simplified DSL for writing selectors.\n\n\nExamples\n\n\nFind all documents where \"year\" is greater than 2010, returning  the fields \n_id\n, \n_rev\n, \nyear\n and \ntitle\n, sorted in ascending order  on \nyear\n. Set the page size to 10.\n\n\nresult = mango_query(db, q\nyear \n 2010\n;\n  fields = [\n_id\n, \n_rev\n, \nyear\n, \ntitle\n],\n  sort   = [Dict(\nyear\n =\n \nasc\n)],\n  limit  = 10)\n\n\n\n\nReturns\n\n\ntype QueryResult\n\n\n\n\n\n\nAPI reference\n\n\nCloudant Query blog post\n\n\n\n\nsource\n\n\n#\n\n\nCouchzilla.paged_mango_query\n \n \nFunction\n.\n\n\npaged_mango_query{T\n:AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  pagesize                   = 100)\n\n\n\n\nPerform multiple HTTP requests against a JSON-type index producing the  intermediate results. This is a wrapper around \nquery()\n using the  \nskip\n and \nlimit\n parameters.\n\n\nExamples\n\n\nfor page in @task paged_mango_query(db, q\ndata = ...\n; pagesize=10)\n  for doc in page.docs\n    # ... \n  end\nend\n\n\n\n\nsource\n\n\n#\n\n\nCouchzilla.mango_index\n \n \nFunction\n.\n\n\nresult = mango_index{T\n:AbstractString}(db::Database, fields::AbstractArray; \n  name::T       = \n,\n  ddoc::T       = \n, \n  selector      = Selector(),\n  default_field = Dict{String, Any}(\nanalyzer\n =\n \nstandard\n, \nenabled\n =\n true))\n\n\n\n\nCreate a Mango index. \n\n\nAll \nkw\n parameters are optional. The fields spec is mandatory for JSON-type indexes. For a  text index, if you give an empty vector as the fields, it will index every field, which is occasionally convenient, but a significant performance drain. The index type will defaults to  type \n\"json\"\n and will be assumed to be \n\"text\"\n if the data in the \nfields\n array are \nDict\ns.  Note that the \ntext\n index type is a Cloudant-only feature.\n\n\nExamples\n\n\n\n\n\n\nMake a text index (Cloudant only)\n\n\nresult = mango_index(db, [Dict(\"name\"=\n\"lastname\", \"type\"=\n\"string\")]; ddoc=\"my-ddoc\",     default_field=Dict(\"analyzer\" =\n \"german\", \"enabled\" =\n true))\n  * Make a json index\n\n\nresult = mango_index(db, [\"data\", \"data2\"])\n\n\n\n\n\n\nReturns\n\n\nmango_index()\n returns a \nDict(...)\n version of the CouchDB response, of the type\n\n\nDict(\n  \nname\n   =\n \ne7d18f69aa0deaa1ffcdf8f705895b61515a6bf6\n,\n  \nid\n     =\n \n_design/e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6\n,\n  \nresult\n =\n \ncreated\n\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.listindexes\n \n \nMethod\n.\n\n\nresult = listindexes(db::Database)\n\n\n\n\nList all existing indexes for the database. This includes views, mango and geo indexes in addition to the primary index.\n\n\nReturns\n\n\nlistindexes()\n returns a \nDict(...)\n version of the CouchDB response:\n\n\nDict(\n  \nindexes\n =\n [\n    Dict(\n      \nname\n =\n \n_all_docs\n,\n      \ndef\n  =\n Dict(\n        \nfields\n =\n [Dict(\n_id\n =\n \nasc\n)]\n      ),\n      \nddoc\n =\n nothing,\n      \ntype\n =\n \nspecial\n\n    ),\n    Dict(\n      \nddoc\n =\n \n_design/cc79a71f562af7ef36deafe511fea9a857b05bcc\n,\n      \nname\n =\n \ncc79a71f562af7ef36deafe511fea9a857b05bcc\n,\n      \ntype\n =\n \ntext\n,\n      \ndef\n  =\n Dict(\n        \nindex_array_lengths\n =\n true,\n        \nfields\n =\n [Dict(\ncust\n =\n \nstring\n), Dict(\nvalue\n =\n \nstring\n)],\n        \ndefault_field\n =\n Dict(\n          \nanalyzer\n =\n \nstandard\n, \n          \nenabled\n =\n true\n        ), \n        \nselector\n =\n Dict(),\n        \ndefault_analyzer\n =\n \nkeyword\n\n      )\n    ), \n    # ...\n  ]\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.mango_deleteindex\n \n \nMethod\n.\n\n\nresult = mango_deleteindex(db::Database; ddoc=\n, name=\n, indextype=\n)\n\n\n\n\nDelete a query index given its ddoc, index name and index type.\n\n\nIndextype is either \"text\" or \"json\".\n\n\nReturns\n\n\nmango_deleteindex()\n returns a \nDict(...)\n version of the CouchDB response:\n\n\nDict(\nok\n =\n true)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n\n\nAttachments\n\n\nYou can attach files to documents in CouchDB. This can occasionally be convenient, but using attachments has performance implications, especially when combined with  replication. See Cloudant's \ndocs\n on  the subject.\n\n\n#\n\n\nCouchzilla.put_attachment\n \n \nMethod\n.\n\n\nput_attachment(db::Database, \n  id::AbstractString, \n  rev::AbstractString, \n  name::AbstractString, \n  mimetype::AbstractString, \n  file::AbstractString)\n\n\n\n\nWrite an attachment to an existing document. Attachment read from a file.\n\n\nExamples\n\n\ndoc = createdoc(db, Dict(\nitem\n =\n \nscreenshot\n))\nresult = put_attachment(db, doc[\nid\n], doc[\nrev\n], \ntest.png\n, \nimage/png\n, \ndata/test.png\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.get_attachment\n \n \nMethod\n.\n\n\nresult = get_attachment(db::Database, id::AbstractString, name::AbstractString; rev::AbstractString = \n)\n\n\n\n\nRead an attachment.\n\n\nExamples\n\n\natt = get_attachment(db, id, \ntest.png\n; rev=rev)\nopen(\ndata/fetched.png\n, \nw\n) do f\n  write(f, att)\nend\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.delete_attachment\n \n \nMethod\n.\n\n\nresult = delete_attachment(db::Database, id::AbstractString, rev::AbstractString, name::AbstractString)\n\n\n\n\nDelete an attachment.\n\n\nExamples\n\n\nresult = delete_attachment(db, id, rev, \ntest.png\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n\n\nReplication\n\n\nUnlike e.g. \nPouchDB\n, \nCDTDatastore\n  and \nsync-android\n, \nCouchzilla\n is not a replication library  in that it does not implement a local data store. However, you have access to all replication-related endpoints provided by CouchDB. The CouchDB replication algorithm is largely undocumented, but a good \nwrite-up\n can be found  in Couchbase's repo.\n\n\n#\n\n\nCouchzilla.changes\n \n \nFunction\n.\n\n\nchanges(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  limit = 0,\n  since = 0)\n\n\n\n\nQuery the CouchDB changes feed, returned as a big \nDict\n. Normal (batch) mode only - for streaming, see \nchanges_streaming()\n.\n\n\nNote that the CouchDB parameter \nlast-event-id\n is not supported. Use \nsince\n to achieve the same thing.\n\n\nExamples\n\n\nresults = changes(db; include_docs=true, since=0)\nfiltered = changes(db; doc_ids=[\n25806e48920b4a35b3c9d9f23c16c821\n, \n644464774951c32fad7243ac8c9745ad\n])\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.changes_streaming\n \n \nFunction\n.\n\n\nchanges_streaming(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  limit = 0,\n  since = 0)\n\n\n\n\nQuery the CouchDB changes feed, line by line. This is a co-routine.  Note that the last item produced will always be the CouchDB \nlast_seq\n  entry.\n\n\nThis is a co-routine. Note that the CouchDB parameter \nlast-event-id\n is  not supported. Use \nsince\n to achieve the same thing.\n\n\nExamples\n\n\nfor ch in @task changes_streaming(db, limit=1)\n  println(ch)\nend\n\nDict(\n  \nseq\n=\n1-g1...gm-\n,\n  \nchanges\n=\n[Dict(\nrev\n=\n1-24213171b98945a2ed3578c926eb3651\n)], \n  \nid\n=\n37f11227ef384458b01e4afc7eed7194\n\n)\nDict(\n  \npending\n=\n213,\n  \nlast_seq\n=\n1-g1...gm-\n\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.revs_diff\n \n \nFunction\n.\n\n\nrevs_diff{T\n:AbstractString}(db::Database; data::Dict{T, Vector{T}} = Dict())\n\n\n\n\nrevs_diff\n is a component of the CouchDB replication algorithm.\n\n\nGiven set of ids and revs, it will return a potentially empty subset of ids and revs from this list which the remote end doesn't have.\n\n\nDict(\n    \n190f721ca3411be7aa9477db5f948bbb\n =\n [\n        \n3-bb72a7682290f94a985f7afac8b27137\n,\n        \n4-10265e5a26d807a3cfa459cf1a82ef2e\n,\n        \n5-067a00dff5e02add41819138abb3284d\n\n    ]\n)\n\n\n\n\nReturns\n\n\nThe returned structure is a \nDict\n where the keys are the \nid\ns of any documents where missing \nrev\ns are found. An example:\n\n\nDict(\n  \ne1132d11a43933948cb46c5e72e13659\n =\n Dict(\n    \nmissing\n =\n [\n2-1f0e2f0d841ba6b7e3d735b870ebeb8c\n],\n    \npossible_ancestors\n =\n [\n1-efda16b0115e5fcf2cfd065faee674fc\n]\n  )\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.bulk_get\n \n \nFunction\n.\n\n\nbulk_get{T\n:AbstractString}(db::Database; data::Vector{Dict{T, T}} = [])\n\n\n\n\nbulk_get\n is used as part of an optimisation of the CouchDB replication algorithm in  recent versions, allowing the replicator to request many documents with full ancestral information in a singe HTTP request.\n\n\nIt is supported in CouchDB \n= 2.0 (Cloudant \"DBNext\"), and also suported by PouchDB.\n\n\nThe \ndata\n parameter is a list of \nDict\ns with keys \nid\n and \nrev\n.\n\n\nExamples\n\n\nresult = revs_diff(db; data = [\n  Dict(\n    \nid\n  =\n \nf6b40e2fdc017e7e4ec4fa88ae3a4950\n, \n    \nrev\n =\n \n2-1f0e2f0d841ba6b7e3d735b870ebeb8c\n\n  ),\n  Dict(\n    \nid\n  =\n \n2f8b7921cbcfde79fb2ff8079cada273\n, \n    \nrev\n =\n \n1-6c3ef2ba29b6631a01ce00f80b5b4ad3\n\n  )    \n])\n\n\n\n\nReturns\n\n\nThe response format is convoluted, and seemingly undocumented for both CouchDB and Cloudant at the time of writing.\n\n\nresults\n: [\n{\n  \nid\n: \n1c43dd76fee5036c0cb360648301a710\n,\n  \ndocs\n: [\n    {\n      \nok\n: { ..doc body here...\n\n        }\n      }\n    }\n  ]\n},\n\n\n\n\nReference\n\n\nsource\n\n\n\n\nGeospatial\n\n\n#\n\n\nCouchzilla.geo_index\n \n \nFunction\n.\n\n\nresult = geo_index(db::Database, ddoc::AbstractString, name::AbstractString, index::AbstractString)\n\n\n\n\nCreate a geospatial index.\n\n\nThe \nindex\n parameter is a string containing an index function in Javascript. \n\n\nExamples\n\n\nresult = geo_index(db, \ngeodd\n, \ngeoidx\n, \n  \nfunction(doc){if(doc.geometry\ndoc.geometry.coordinates){st_index(doc.geometry);}}\n\n)\n\n\n\n\nReturns\n\n\nReturns a \nDict(...)\n from the CouchDB response, of the type\n\n\nDict(\n  \nok\n  =\n true, \n  \nrev\n =\n \n1-b950984b19bb1b8bb43513c9d5b235bc\n,\n  \nid\n  =\n \n_design/geodd\n\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.geo_indexinfo\n \n \nFunction\n.\n\n\nresult = geo_indexinfo(db::Database, ddoc::AbstractString, name::AbstractString)\n\n\n\n\nRetrieve stats for a geospatial index.\n\n\nExamples\n\n\nresult = geo_indexinfo(db, \ngeodd\n, \ngeoidx\n)\n\n\n\n\nReturns\n\n\nReturns a \nDict(...)\n from the CouchDB response, of the type\n\n\nDict(\n  \nname\n =\n \n_design/geodd/geoidx\n,\n  \ngeo_index\n =\n Dict(\n    \ndoc_count\n =\n 269,\n    \ndisk_size\n =\n 33416,\n    \ndata_size\n =\n 26974\n  )\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.geo_query\n \n \nFunction\n.\n\n\ngeo_query(db::Database, ddoc::AbstractString, name::AbstractString;\n  lat::Float64    = -360.0,\n  lon::Float64    = -360.0,\n  rangex::Float64 = 0.0,\n  rangey::Float64 = 0.0,\n  radius::Float64 = 0.0,\n  bbox::Vector{Float64}  = Vector{Float64}(),\n  relation::AbstractString = \nintersects\n,\n  nearest = false,\n  bookmark::AbstractString = \n,\n  format::AbstractString = \nview\n, \n  skip = 0,\n  limit = 0,\n  stale = false,\n  g::AbstractString = \n)\n\n\n\n\nQuery a geospatial index. This quickly becomes complicated. See the references below. \n\n\nThe \"g\" parameter is a string representing a \nWell Known Text\n object (\nWKT\n). It can be used to describe various geometries, such as lines and polygons. Currently supported  geometric objects are\n\n\n\n\npoint\n\n\nlinestring\n\n\npolygon\n\n\nmultipoint\n\n\nmultilinestring\n\n\nmultipolygon\n\n\ngeometrycollection\n\n\n\n\nGeo queries can be configured to return its results in a number of different formats using the \nformat\n parameter. The accepted values are:\n\n\n\n\nlegacy\n\n\ngeojson\n\n\nview (default)\n\n\napplication/vnd.geo+json\n\n\n\n\nThe \nrelation\n parameter follows the \nDE-9IM\n spec for geometric relationships. Acceptable values are:\n\n\n\n\ncontains\n\n\ncontains_properly\n\n\ncovered_by\n\n\ncovers\n\n\ncrosses\n\n\ndisjoint\n\n\nintersects (default)\n\n\noverlaps\n\n\ntouches\n\n\nwithin\n\n\n\n\nExamples\n\n\nRadial query\n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)\n\n\n\n\nPolygon query \n\n\nresult = geo_query(geodb, \ngeodd\n, \ngeoidx\n;\n  g=\nPOLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0))\n)\n\n\n\n\nAPI reference\n\n\nsource\n\n\n\n\nAuth\n\n\n#\n\n\nCouchzilla.get_permissions\n \n \nFunction\n.\n\n\ndata = get_permissions(db::Database)\n\n\n\n\nFetch all current permissions. Note: this is Cloudant-specific.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.set_permissions\n \n \nFunction\n.\n\n\nresult = set_permissions(db::Database, current::Dict=Dict{AbstractString, Any}(); key=\n, roles=[])\n\n\n\n\nModify permissions. Note: this is Cloudant-specific.\n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.make_api_key\n \n \nFunction\n.\n\n\ndata = make_api_key(client::Client)\n\n\n\n\nGenerate a new API key. Note: this is Cloudant-specific.\n\n\nNote also that API keys take a long time to propagate around a cluster. It's unsafe to rely on a newly created key to be immediately available. The reason for this is that Cloudant keeps its auth-related documents centrally, and replicate out to all clusters. \n\n\nAPI reference\n\n\nsource\n\n\n#\n\n\nCouchzilla.delete_api_key\n \n \nFunction\n.\n\n\nresult = delete_api_key(db::Database, key::AbstractString)\n\n\n\n\nRemove an existing API key. Note: this is Cloudant-specific. This is implemented via \nset_permissions()\n.\n\n\nAPI reference\n\n\nsource\n\n\n\n\nUtility stuff\n\n\n#\n\n\nCouchzilla.retry_settings!\n \n \nMethod\n.\n\n\nretry_settings!(;enabled=false, max_retries=5, delay_ms=10)\n\n\n\n\nSet parameters for retrying requests failed with a 429: Too Many Requests. This is Cloudant-specific, but safe to leave enabled if using CouchDB, as the error will never be encountered.\n\n\nFailed requests are retried after a growing interval according to\n\n\nsleep((tries * delay_ms + rand(1:10))/1000.0)\n\n\n\n\nuntil \ntries\n exceed \nmax_retries\n or the request succeeds.\n\n\nNote: it is not sufficient to rely on this behaviour on a rate-limited Cloudant cluster, as persistently hitting the limits can only be fixed by moving to higher reserved  throughput capacity. For this reason this is disabled by default.\n\n\nsource\n\n\n#\n\n\nCouchzilla.retry_settings\n \n \nFunction\n.\n\n\nretry_settings()\n\n\n\n\nReturn the current retry settings.\n\n\nsource\n\n\n#\n\n\nCouchzilla.relax\n \n \nFunction\n.\n\n\nrelax(fun, url_string; cookies=nothing, query=Dict(), headers=Dict())\n\n\n\n\nMakes an HTTP request with the relevant cookies and query strings and deserialises the response, assumed to be json.\n\n\nCloudant implements request throttling based on reerved throughput capacity. Hitting a  capacity limit will return a 429 error (Too many requests). This is Cloudant-specific.\n\n\nThis function can retry on 429 if this behaviour is enabled. See \nretry_settings()\n.\n\n\nsource\n\n\n#\n\n\nCouchzilla.endpoint\n \n \nFunction\n.\n\n\nendpoint(uri::URI, path::AbstractString)\n\n\n\n\nAppends a path string to the URI, returning as a string.\n\n\nsource", 
            "title": "Introduction"
        }, 
        {
            "location": "/#couchzilla", 
            "text": "Couchzilla \u2013 CouchDB/Cloudant access for Julians.", 
            "title": "Couchzilla"
        }, 
        {
            "location": "/#philosophy", 
            "text": "We've tried to wrap the CouchDB API as thinly as possible, hiding the JSON and the HTTP but no  overwrought abstractions on top. That means that a CouchDB JSON document is represented as the  corresponding de-serialisation into native Julia types:  {\n   _id :  45c4affe6f40c7aaf0ba533f7a6601a2 ,\n   _rev :  1-47e8deed9ccfcf8d061f7721d3ba085c ,\n   item :  Malus domestica ,\n   prices : {\n     Fresh Mart : 1.59,\n     Price Max : 5.99,\n     Apples Express : 0.79\n  }\n}  is represented as   Dict{UTF8String,Any}(\n   _rev    =   1-47e8deed9ccfcf8d061f7721d3ba085c ,\n   prices  =  Dict{UTF8String,Any}( Fresh Mart = 1.59, Price Max = 5.99, Apples Express = 0.79),\n   _id     =   45c4affe6f40c7aaf0ba533f7a6601a2 ,\n   item    =   Malus domestica \n)  Along similar lines, Couchzilla will return CouchDB's JSON-responses simply converted as-is.", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#couchdb-vs-cloudant", 
            "text": "IBM Cloudant  offers a clustered version of CouchDB as a service. What started out as  a fork has with version 2.0 och CouchDB now largely come back togther, and Cloudant now does (nearly) all  its work directly in the Apache CouchDB repos. However, some features of Cloudant makes no sense in the CouchDB context, so there are still some differences. Couchzilla tries to cover both bases, but makes no attempt to hide Cloudant-only functionality when using CouchDB.  The main differences are:   Text indexes - Cloudant integrates with Lucene. CouchDB only has json indexes in its Mango implementation.  Rate capping - as Cloudant sells its service in terms of provisioned throughput capacity, Cloudant will occasionally throw a 429 error indicating that the cap has been hit.  API keys \u2013 Cloudant has a separate auth system distinct from CouchDB's  _users  database.  Geospatial indexes \u2013\u00a0Cloudant has sophisticated geospatial capabilities which are not present in CouchDB.", 
            "title": "CouchDB vs Cloudant"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Couchzilla defines two types,  Client  and  Database .  Client  represents an authenticated  connection to the remote CouchDB  instance . Using this you can perform database-level operations,  such as creating, listing and deleting databases. The Database immutable type represents a client that is connected to a specific database, allowing you to perform document-level operations.  Install the library using the normal Julia facilities  Pkg.add(\"Couchzilla\") .  Let's load up the credentials from environment variables.  username = ENV[ COUCH_USER ]\npassword = ENV[ COUCH_PASS ]\nhost     = ENV[ COUCH_HOST_URL ] # e.g. https://accountname.cloudant.com  We can now create a client connection, and use that to create a new database:  dbname =  mynewdb \nclient = Client(username, password, host)\ndb, created = createdb(client, dbname)  If the database already existed,  created  will be set to  false  on return, and  true  means that the database was created.  We can now add documents to the new database using  createdoc . It returns an array of   Dict s showing the  {id, rev}  tuples of the new documents:  result = createdoc(db, [\n    Dict( name  =   adam ,     data  =   hello ),\n    Dict( name  =   billy ,    data  =   world ),\n    Dict( name  =   cecilia ,  data  =   authenticate ),\n    Dict( name  =   davina ,   data  =   cloudant ),\n    Dict( name  =   eric ,     data  =   blobbyblobbyblobby )\n])  5-element Array{Any,1}:\n Dict{String,Any}(Pair{String,Any}( ok ,true),Pair{String,Any}( rev , 1-783f91178091c10cce61c326473e8849 ),Pair{String,Any}( id , 93790b75ed6a59e5002cb0eddb78b42d ))\n Dict{String,Any}(Pair{String,Any}( ok ,true),Pair{String,Any}( rev , 1-9ecba7e9a824a6fdcfb005c454fea12e ),Pair{String,Any}( id , 93790b75ed6a59e5002cb0eddb78b69c ))\n Dict{String,Any}(Pair{String,Any}( ok ,true),Pair{String,Any}( rev , 1-e05530fc65101ed432c5ee457d327952 ),Pair{String,Any}( id , 93790b75ed6a59e5002cb0eddb78c304 ))\n Dict{String,Any}(Pair{String,Any}( ok ,true),Pair{String,Any}( rev , 1-446bb325003aa6a995bde4e7c3dd513f ),Pair{String,Any}( id , 93790b75ed6a59e5002cb0eddb78c867 ))\n Dict{String,Any}(Pair{String,Any}( ok ,true),Pair{String,Any}( rev , 1-e1f2181b3b4d7fa285b4516eee02d287 ),Pair{String,Any}( id , 93790b75ed6a59e5002cb0eddb78c8a1 ))  This form of  createdoc  creates multiple documents using a single  HTTP POST  which is  the most efficient way of creating multiple new documents.  We can read a document back using  readdoc , hitting the CouchDB primary index. Note that  reading back a document you just created is normally bad practice, as it will sooner or  later fall foul of CouchDB's  eventual consistency   and give rise to sporadic, hard to troubleshoot errors. Having said that, let's do it  anyway, and hope for the best:  id = result[2][ id ]\nreaddoc(db, id)  Dict{String,Any} with 4 entries:\n   _rev  =   1-9ecba7e9a824a6fdcfb005c454fea12e \n   name  =   billy \n   _id   =   93790b75ed6a59e5002cb0eddb78b69c \n   data  =   world  returning the winning revision for the given  id  as a  Dict .  Conflict handling  in CouchDB and eventual  consistency is beyond the scope of this documentation, but worth understanding fully before using  CouchDB in anger.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#query", 
            "text": "Mango  (also known as  Cloudant Query ) is  a declarative query language inspired by  MongoDB . It allows us to query the database in a (slightly) more ad-hoc fashion than using map reduce views.  In order to use this feature we first need to set up the necessary indexes:  mango_index(db, [ name ,  data ])  Dict{String,Any} with 3 entries:\n   name    =   f519be04f7f80838b6a88811f75de4fb83d966dd \n   id      =   _design/f519be04f7f80838b6a88811f75de4fb83d966dd \n   result  =   created  We can now use this index to retrieve data:  mango_query(db, q name=davina )  Couchzilla.QueryResult(Dict{AbstractString,Any}[Dict{AbstractString,Any}(Pair{AbstractString,Any}( _rev , 1-446bb325003aa6a995bde4e7c3dd513f ),Pair{AbstractString,Any}( name , davina ),Pair{AbstractString,Any}( _id , 93790b75ed6a59e5002cb0eddb78c867 ),Pair{AbstractString,Any}( data , cloudant ))], )  The construct  q\"...\"  (see  @q_str ) is a custom string literal type which takes a simplistic DSL  expression which gets converted to the actual JSON-representation of a Mango selector. If you are familiar with  Mango selectors ,  you can use the raw JSON expression if you prefer:  mango_query(db, Selector( {\\ name\\ :{\\ \\$eq\\ :\\ davina\\ }} ))  Couchzilla.QueryResult(Dict{AbstractString,Any}[Dict{AbstractString,Any}(Pair{AbstractString,Any}( _rev , 1-446bb325003aa6a995bde4e7c3dd513f ),Pair{AbstractString,Any}( name , davina ),Pair{AbstractString,Any}( _id , 93790b75ed6a59e5002cb0eddb78c867 ),Pair{AbstractString,Any}( data , cloudant ))], )  There are also coroutine versions of some of the functions that return data from views. If we had many results to process, we could use  paged_mango_query  in a Julia Task:  for page in @task paged_mango_query(db, q name=davina ; pagesize=10)\n    # Do something with the page.docs array\nend  This version uses the  limit  and  skip  parameters and issues an HTTP(S) request per page.", 
            "title": "Query"
        }, 
        {
            "location": "/#views", 
            "text": "A powerful feature of CouchDB are  secondary indexes ,  known as  views . They are created using  a map function written most commonly in Javascript, and optionally a reduce part. For  example, to create a view on the  name  field, we use the following:  view_index(db,  my_ddoc ,  my_view , \nfunction(doc) {\n  if(doc   doc.name) {\n    emit(doc.name, 1);\n  }\n} )  Dict{String,Any} with 3 entries:\n   ok   =  true\n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc \n   id   =   _design/my_ddoc  To read from this view, use the  view_query  method:  view_query(db,  my_ddoc ,  my_view ; keys=[ davina ,  billy ])  Dict{String,Any} with 3 entries:\n   rows        =  Any[Dict{String,Any}(Pair{String,Any}( key , davina ),Pair{St\u2026\n   offset      =  1\n   total_rows  =  5  Cloudant has an interactive tool for trying out Mango Query which is a useful resource:  Cloudant Query demo", 
            "title": "Views"
        }, 
        {
            "location": "/#using-attachments", 
            "text": "CouchDB can store files alongside documents as attachments. This can be a convenient feature for many applications, but it has drawbacks, especially in terms of performance. If you find that you need to store large (say greater than a couple of meg) binary attachments, you should probably consider a dedicated, separate file store and only use CouchDB for metadata.  To write an attachment, use  put_attachment , which expects an  {id, rev}  tuple referencing and existing document in the database and the path to the file holding the attachment:  data = createdoc(db, Dict( item  =   screenshot ))\nresult = put_attachment(db, data[ id ], data[ rev ],  test.png ,  image/png ,  data/test.png )  In order to read the attachment, use  get_attachment , which returns an IO stream:  att = get_attachment(db, result[ id ],  test.png ; rev=result[ rev ])\nopen( data/fetched.png ,  w ) do f\n  write(f, att)\nend", 
            "title": "Using attachments"
        }, 
        {
            "location": "/#geospatial-queries", 
            "text": "One of the fancier aspects of Cloudant is its geospatial capabilities, and Couchzilla provides access to this functionality. Using this it is possible to use Cloudant to  answer questions such as \"show me all documents that fall within a given radius of a given point\". A full description of this capability is beyond the scope of this  document, but Cloudant provides rich documentation on the  subject .  In order to try out the geospatial stuff using Couchzilla, we first need some data.  Cloudant provides an open database that you can replicate into your own account   here . It's a database of the locations of  reported crimes in the Boston area.  Let's connect Couchzilla to a replica of this database, and run through the examples from Cloudant's geospatial tutorial  page .  We can re-use the client from before:  geodb = connectdb(client,  crimes )  The database already contains the necessary geospatial indexes. Had this not been the case we could have indexed it using  geo_index .  So let's list the first 20 crimes within a radius of 10,000m of the Boston State House:  result = geo_query(geodb,  geodd ,  geoidx ;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)\nresult[ rows ]  200-element Array{Any,1}:\n Dict{String,Any}(Pair{String,Any}( rev , 1-caa129c6e0c9e7667cd401675859da2a ),Pair{String,Any}( id , 79f14b64c57461584b152123e38fcf2b ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0666,42.3593]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-e7c7eb51c49d7e5fab38b33b19542106 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38c548a ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0646,42.3612]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-de437f29d19bb55a495693fa40975962 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38b22cc ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.06,42.3616]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-4c4650e64d0cc0bb01e32a0b5aca2802 ),Pair{String,Any}( id , 79f14b64c57461584b152123e3917804 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.06,42.3616]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-e557e2555201054b924f618299cb9b64 ),Pair{String,Any}( id , 79f14b64c57461584b152123e392e828 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.06,42.3616]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-86261a0030776d68d98f805afec21c94 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38a779d ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0587,42.3594]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-0892e7f4eb551df2453e9a11b274e190 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38d6b78 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0587,42.3594]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-4ce963293c1810c3fc8fe606e9345e8e ),Pair{String,Any}( id , 79f14b64c57461584b152123e38ee226 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0587,42.3594]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-816e850ff5ec2249993675fd568b2e9c ),Pair{String,Any}( id , 79f14b64c57461584b152123e3927629 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0587,42.3594]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-59e512ec186a17dc3e94a3f1d7c13392 ),Pair{String,Any}( id , 79f14b64c57461584b152123e392867d ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0587,42.3594]),Pair{String,Any}( type , Point ))))\n \u22ee\n Dict{String,Any}(Pair{String,Any}( rev , 1-be45124918034417ce77adbd99d3d54f ),Pair{String,Any}( id , 79f14b64c57461584b152123e38c8ead ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.1331,42.3634]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-e17545f877d7fc1442abe71557ec44c8 ),Pair{String,Any}( id , 79f14b64c57461584b152123e391c876 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.1073,42.3038]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-50e1dd9b9ad194f90a0fb4f9001d1b43 ),Pair{String,Any}( id , 79f14b64c57461584b152123e3929889 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0551,42.289]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-f8407a2467b8fea166aa451994de75da ),Pair{String,Any}( id , 79f14b64c57461584b152123e38b682a ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0773,42.2896]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-459aadf6156187de8c11ecce3b5f1f28 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38afe98 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0501,42.2897]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-1d1c012db58954c6d799646e0e009728 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38b0d38 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0473,42.2902]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-21dea1eb417bff225b4932acbe983314 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38c9b44 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.1097,42.3042]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-edd6492692311118baaa8cbb980ef1c5 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38d51e7 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.1341,42.349]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-13144e283f47d611d62d9f11d94161be ),Pair{String,Any}( id , 79f14b64c57461584b152123e39168d7 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.135,42.3504]),Pair{String,Any}( type , Point ))))  We can specify a polygon for the Commercial Street corridor, which should yield only two docs:  result = geo_query(geodb,  geodd ,  geoidx ;\n  g= POLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0)) )\nresult[ rows ]  2-element Array{Any,1}:\n Dict{String,Any}(Pair{String,Any}( rev , 1-f0551b24741f182c5944621f87f9ac76 ),Pair{String,Any}( id , 79f14b64c57461584b152123e38d6349 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.0511,42.3651]),Pair{String,Any}( type , Point ))))\n Dict{String,Any}(Pair{String,Any}( rev , 1-8a9f1673b2b15232bbbb956a7f3b5397 ),Pair{String,Any}( id , 79f14b64c57461584b152123e3924516 ),Pair{String,Any}( geometry ,Dict{String,Any}(Pair{String,Any}( coordinates ,Any[-71.052,42.3667]),Pair{String,Any}( type , Point ))))  If you want to delete a database, simply call  deletedb :  deletedb(client, dbname)  Dict{String,Any} with 1 entry:\n   ok  =  true", 
            "title": "Geospatial queries"
        }, 
        {
            "location": "/#handling-cloudants-rate-capping", 
            "text": "Cloudant pushes most of its stuff to upstream to  Apache CouchDB . However, not everything Cloudant does makes sense for CouchDB, and once such example is throughput throttling. Cloudant, currently only in its Bluemix guise, prices its service in terms of provisioned throughput capacity for lookups, writes and queries. This means that you purchase a certain max number of requests per second, bucketed by type. This is similar in spirit to how other purveyors of database services price their services (e.g.  DynamoDB ).   When you hit capacity, Cloudant will return an error, signified by the HTTP status code 429 ( Too many requests ). This means that the request was not successful, and will need to be retried at a later stage. Couchzilla optionally gives you a way to deal with 429 errors:  retry_settings!(;enabled=true, max_retries=5, delay_ms=10)  This will enable the retrying of requests failed with a 429. This will try a request a maximum of 5 times, with a delay of 10 ms added cumulatively, plus a little bit of noise (randomly between 1 and 10 ms). This is a module-global setting, so will apply to all  Client s created within the same  Julia  session.  You can retrieve the current settings using:  retry_settings()  Note that this behaviour is not enabled by default, and relying on it alone on a rate-capped cluster will only help with temporary transgressions \u2013 your own code must still handle the case where the max retries are exceeded.", 
            "title": "Handling Cloudant's rate capping"
        }, 
        {
            "location": "/#using-cloudants-api-keys-for-auth", 
            "text": "Cloudant has an auth system distinct from the CouchDB traditional style based on the  _users  database. By using API keys you can grant and revoke a client application's access. API keys have roles attached to them, a combination of  _admin ,  _reader ,  _writer ,  _replicator  and  _creator . It's not quite as straight-forward as it may seem.  _reader  grants read-only access. TODO  In order to use the API key system, you need two steps:    Create the key using  data = make_api_key(client::Client)\n2. Assign key to a database, with the appropriate roles  current = get_permissions(db)  result = set_permissions(db, current; key=data[\"key\"], roles=[\"_reader\", \"_writer\"])\n3. Create a new client connection using the new key  api_client = Client(data[\"key\"], data[\"password\"], host)\n4. Create a database connection using the new client  api_db = connectdb(api_client, \"dbname\")    There is one gotcha here that you need to be aware of. API keys are created on a central Cloudant admin cluster, and then replicated back to the one you're using. This means that running through the four steps above may occasionally fail to authenticate (step 3) for a good few minutes whilst the update percolates through. It helps to treat API keys as something to be created up front, rather than on the fly.", 
            "title": "Using Cloudant's API keys for auth"
        }, 
        {
            "location": "/#client", 
            "text": "#  Couchzilla.Client     Type .  type Client\n  url\n  cookies\n\n  Client(username::AbstractString, password::AbstractString, urlstr::AbstractString; auth=true) = \n    cookieauth!(new(URI(urlstr)), username, password, auth)\nend  The Client type represents an authenticated connection to a remote CouchDB/Cloudant instance.  source  #  Couchzilla.connectdb     Method .  db = connectdb(client::Client, database::AbstractString)  Return an immutable Database reference.  Subsequent database-level operations will operate on the chosen database.  If you need to operate on a different database, you need to create a new  Database reference.  connectdb(...)  does not check that the chosen remote  database exists.  source  #  Couchzilla.createdb     Method .  db, created = createdb(client::Client, database::AbstractString)  Create a new database on the remote end called  dbname . Return an immutable  Database reference to this newly created db, and a boolean which is true if  a database was created, false if it already existed.  API reference  source  #  Couchzilla.dbinfo     Method .  info = dbinfo(client::Client, name::AbstractString)  Return the meta data about the  dbname  database.  API reference  source  #  Couchzilla.listdbs     Method .  dblist = listdbs(client::Client)  Return a list of all databases under the authenticated user.  API reference  source  #  Couchzilla.deletedb     Method .  result = deletedb(client::Client, name::AbstractString)  Delete the named database.  API reference  source  #  Couchzilla.cookieauth!     Function .  cookieauth!(client::Client, username::AbstractString, password::AbstractString, auth::Bool=true)  Private. Hits the  _session  endpoint to obtain a session cookie that is used to authenticate subsequent requests. If  auth  is set to  false, this does nothing.  API reference  source", 
            "title": "Client"
        }, 
        {
            "location": "/#database", 
            "text": "The Database type represents a client connection tied to a specific database name. This is  immutable, meaning that if you need to talk to several databases you need to create one Database type for each.  #  Couchzilla.Database     Type .  immutable Database\n  url\n  name\n  client\n\n  Database(client::Client, name::AbstractString) =\n    new(URI(client.url.scheme, client.url.host, client.url.port,  /$name ), name, client)\nend  The Database immutable is a client connection tied to a specific remote DB. It is  normally not created directly, but via a call to  connectdb() , or  createdb() .   Examples  # Connect to existing DB. Does not verify it exists.\ndb = connectdb(client; database= mydb )\n\n# Create a new db if it doesn't exist, otherwise connect \ndb, created = createdb(client; database= mydb )  source  #  Couchzilla.bulkdocs     Method .  result = bulkdocs(db::Database; data=[], options=Dict())  Raw _bulk_docs.  This is a function primarily intended for internal use, but can be used directly to create, update or delete documents in bulk, so as to save on the HTTP overhead.  API reference  source  #  Couchzilla.createdoc     Method .  result = createdoc(db::Database, body::Dict)  Create one new document.  Note that this is implemented via the  _bulk_docs  endpoint, rather  than a  POST  to the  /{DB} .  API reference  source  #  Couchzilla.createdoc     Method .  result = createdoc(db::Database, data::AbstractArray  Bulk create a set of new documents via the CouchDB  _bulk_docs  endpoint.  API reference  source  #  Couchzilla.readdoc     Method .  result = readdoc(db::Database, id::AbstractString; \n  rev               =  , \n  attachments       = false, \n  att_encoding_info = false,\n  atts_since        = [],\n  open_revs         = [],\n  conflicts         = false,\n  deleted_conflicts = false,\n  latest            = false,\n  meta              = false,\n  revs              = false,\n  revs_info         = false)  Fetch a document by  id .  For a description of the parameters, see reference below. To use the  open_revs  parameter as  all , use  result = readdoc(db, id; open_revs=[ all ])  API reference  source  #  Couchzilla.updatedoc     Method .  result = updatedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing, body=Dict())  Update an existing document, creating a new revision.  Implemented via the _bulk_docs endpoint.  API reference  source  #  Couchzilla.deletedoc     Method .  result = deletedoc(db::Database; id::AbstractString=nothing, rev::AbstractString=nothing)  Delete a document revision. Implemented via the _bulk_docs endpoint:  API reference  source", 
            "title": "Database"
        }, 
        {
            "location": "/#views_1", 
            "text": "#  Couchzilla.view_index     Method .  result = view_index(db::Database, ddoc::AbstractString, name::AbstractString, map::AbstractString; \n  reduce::AbstractString =  )  Create a secondary index.  The  map  is a string containing a map function in Javascript. Currently,  make_view   can only create a single view per design document.  The optional  reduce  parameter is a string containing either a custom Javascript reducer (best avoided for performance reasons) or the name of a built-in Erlang  reducer, e.g.  \"_stats\" .  Examples  result = view_index(db,  my_ddoc ,  my_view ,  function(doc){if(doc doc.name){emit(doc.name,1);}} )  Returns  Returns a  Dict(...)  from the CouchDB response, of the type  Dict(\n   ok   =  true, \n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc ,\n   id   =   _design/my_ddoc \n)  API reference  source  #  Couchzilla.view_query     Function .  result = view_query(db::Database, ddoc::AbstractString, name::AbstractString;\n  descending    = false,\n  endkey        =  ,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  group         = false,\n  group_level   = 0,\n  reduce        = true,\n  key           =  ,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      =  )  Query a secondary index.  Examples  # Query the view for a known key subset\nresult = view_query(db,  my_ddoc ,  my_view ; keys=[ adam ,  billy ])  Returns  Dict(\n   rows  =  [\n    Dict( key  =   adam ,  id  =   591c02fa8b8ff14dd4c0553670cc059a ,  value  =  1),\n    Dict( key  =   billy ,  id  =   591c02fa8b8ff14dd4c0553670cc13c1 ,  value  =  1)\n  ],\n   offset  =  0,\n   total_rows  =  7 \n)  API reference  source  #  Couchzilla.alldocs     Function .  alldocs(db::Database;\n  descending    = false,\n  endkey        =  ,\n  include_docs  = false,\n  conflicts     = false,\n  inclusive_end = true,\n  key           =  ,\n  keys          = [],\n  limit         = 0,\n  skip          = 0,\n  startkey      =  )  Return all documents in the database by the primary index.  The optional parameters are:   descending     true/false   \u2013 lexicographical ordering of keys. Default false.  endkey         id           \u2013 stop when  endkey  is reached. Optional.  startkey       id           \u2013 start at  startkey . Optional.  include_docs   true/false   \u2013 return the document body. Default false.  conflicts      true/false   \u2013 also return any conflicting revisions. Default false.  inclusive_end  true/false   \u2013 if  endkey  is given, should this be included? Default true  key            id           \u2013 return only specific key. Optional.  keys           [id, id,...] \u2013 return only specific set of keys (will POST). Optional.  limit          int          \u2013 return only max  limit  number of rows. Optional.  skip           int          \u2013 skip over the first  skip  number of rows. Default 0.   API reference  source", 
            "title": "Views"
        }, 
        {
            "location": "/#mangocloudant-query", 
            "text": "#  Couchzilla.Selector     Type .  immutable Selector\n  dict::Dict{AbstractString, Any}\nend  Immutable represention of a Mango Selector used to query a Mango index.  Usually created using the custom string literal  q\"...\"  (see the  @q_str  macro), but can be created directly from either the raw json string containing a Selector expression or a Julia  Dict(...)  representing the same.  Examples  sel = q name = bob \nsel = Selector( { name :{ $eq : bob }} )\nsel = Selector(Dict( name  =  Dict( $eq  =   bob )))\nsel = and([q name = bob , q age   18 ])  API reference  source  #  Couchzilla.Selector     Method .  Selector()  The empty Selector.  source  #  Couchzilla.Selector     Method .  Selector(raw_json::AbstractString)  Create a Selector from the raw json.  API reference  source  #  Base.isempty     Function .  isempty(sel::Selector)  True if sel is the empty Selector.  source  #  Couchzilla.@q_str     Macro .  q .....  Custom string literal for a limited Selector definition DSL.  It takes the form:  field op data  where  field  is a field name, op is one of   =, !=,  ,  =,  ,  =, in, !in, all  This allows you to write things like:  q name = bob \nq value   5 \nq occupation in [fishmonger, pilot, welder]  Note that the Selector DSL only covers a fraction of the full Selector syntax. It can be used with the boolean functions  and() ,  or()  etc to build up more complex Selectors, e.g.  sel = and([q\"name = bob\", q\"age   18\"])  For more information on the actual Selector syntax, see link below.  API reference  source  #  Couchzilla.QueryResult     Type .  type QueryResult\n  docs::Vector{Dict{AbstractString, Any}}\n  bookmark::AbstractString \nend  Returned by  query(...) .  bookmark  is only relevant when querying indexes of type  text .  source  #  Couchzilla.mango_query     Function .  result = mango_query{T :AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  limit                      = 0,\n  skip                       = 0,\n  bookmark                   =  )  Query database (Mango/Cloudant Query).  See the  Selector  type and the associated  q\"...\"  custom string literal which implements a simplified DSL for writing selectors.  Examples  Find all documents where \"year\" is greater than 2010, returning  the fields  _id ,  _rev ,  year  and  title , sorted in ascending order  on  year . Set the page size to 10.  result = mango_query(db, q year   2010 ;\n  fields = [ _id ,  _rev ,  year ,  title ],\n  sort   = [Dict( year  =   asc )],\n  limit  = 10)  Returns  type QueryResult   API reference  Cloudant Query blog post   source  #  Couchzilla.paged_mango_query     Function .  paged_mango_query{T :AbstractString}(db::Database, selector::Selector;\n  fields::Vector{T}          = Vector{AbstractString}(),\n  sort::Vector{Dict{T, Any}} = Vector{Dict{AbstractString, Any}}(),\n  pagesize                   = 100)  Perform multiple HTTP requests against a JSON-type index producing the  intermediate results. This is a wrapper around  query()  using the   skip  and  limit  parameters.  Examples  for page in @task paged_mango_query(db, q data = ... ; pagesize=10)\n  for doc in page.docs\n    # ... \n  end\nend  source  #  Couchzilla.mango_index     Function .  result = mango_index{T :AbstractString}(db::Database, fields::AbstractArray; \n  name::T       =  ,\n  ddoc::T       =  , \n  selector      = Selector(),\n  default_field = Dict{String, Any}( analyzer  =   standard ,  enabled  =  true))  Create a Mango index.   All  kw  parameters are optional. The fields spec is mandatory for JSON-type indexes. For a  text index, if you give an empty vector as the fields, it will index every field, which is occasionally convenient, but a significant performance drain. The index type will defaults to  type  \"json\"  and will be assumed to be  \"text\"  if the data in the  fields  array are  Dict s.  Note that the  text  index type is a Cloudant-only feature.  Examples    Make a text index (Cloudant only)  result = mango_index(db, [Dict(\"name\"= \"lastname\", \"type\"= \"string\")]; ddoc=\"my-ddoc\",     default_field=Dict(\"analyzer\" =  \"german\", \"enabled\" =  true))\n  * Make a json index  result = mango_index(db, [\"data\", \"data2\"])    Returns  mango_index()  returns a  Dict(...)  version of the CouchDB response, of the type  Dict(\n   name    =   e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6 ,\n   id      =   _design/e7d18f69aa0deaa1ffcdf8f705895b61515a6bf6 ,\n   result  =   created \n)  API reference  source  #  Couchzilla.listindexes     Method .  result = listindexes(db::Database)  List all existing indexes for the database. This includes views, mango and geo indexes in addition to the primary index.  Returns  listindexes()  returns a  Dict(...)  version of the CouchDB response:  Dict(\n   indexes  =  [\n    Dict(\n       name  =   _all_docs ,\n       def   =  Dict(\n         fields  =  [Dict( _id  =   asc )]\n      ),\n       ddoc  =  nothing,\n       type  =   special \n    ),\n    Dict(\n       ddoc  =   _design/cc79a71f562af7ef36deafe511fea9a857b05bcc ,\n       name  =   cc79a71f562af7ef36deafe511fea9a857b05bcc ,\n       type  =   text ,\n       def   =  Dict(\n         index_array_lengths  =  true,\n         fields  =  [Dict( cust  =   string ), Dict( value  =   string )],\n         default_field  =  Dict(\n           analyzer  =   standard , \n           enabled  =  true\n        ), \n         selector  =  Dict(),\n         default_analyzer  =   keyword \n      )\n    ), \n    # ...\n  ]\n)  API reference  source  #  Couchzilla.mango_deleteindex     Method .  result = mango_deleteindex(db::Database; ddoc= , name= , indextype= )  Delete a query index given its ddoc, index name and index type.  Indextype is either \"text\" or \"json\".  Returns  mango_deleteindex()  returns a  Dict(...)  version of the CouchDB response:  Dict( ok  =  true)  API reference  source", 
            "title": "Mango/Cloudant Query"
        }, 
        {
            "location": "/#attachments", 
            "text": "You can attach files to documents in CouchDB. This can occasionally be convenient, but using attachments has performance implications, especially when combined with  replication. See Cloudant's  docs  on  the subject.  #  Couchzilla.put_attachment     Method .  put_attachment(db::Database, \n  id::AbstractString, \n  rev::AbstractString, \n  name::AbstractString, \n  mimetype::AbstractString, \n  file::AbstractString)  Write an attachment to an existing document. Attachment read from a file.  Examples  doc = createdoc(db, Dict( item  =   screenshot ))\nresult = put_attachment(db, doc[ id ], doc[ rev ],  test.png ,  image/png ,  data/test.png )  API reference  source  #  Couchzilla.get_attachment     Method .  result = get_attachment(db::Database, id::AbstractString, name::AbstractString; rev::AbstractString =  )  Read an attachment.  Examples  att = get_attachment(db, id,  test.png ; rev=rev)\nopen( data/fetched.png ,  w ) do f\n  write(f, att)\nend  API reference  source  #  Couchzilla.delete_attachment     Method .  result = delete_attachment(db::Database, id::AbstractString, rev::AbstractString, name::AbstractString)  Delete an attachment.  Examples  result = delete_attachment(db, id, rev,  test.png )  API reference  source", 
            "title": "Attachments"
        }, 
        {
            "location": "/#replication", 
            "text": "Unlike e.g.  PouchDB ,  CDTDatastore   and  sync-android ,  Couchzilla  is not a replication library  in that it does not implement a local data store. However, you have access to all replication-related endpoints provided by CouchDB. The CouchDB replication algorithm is largely undocumented, but a good  write-up  can be found  in Couchbase's repo.  #  Couchzilla.changes     Function .  changes(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  limit = 0,\n  since = 0)  Query the CouchDB changes feed, returned as a big  Dict . Normal (batch) mode only - for streaming, see  changes_streaming() .  Note that the CouchDB parameter  last-event-id  is not supported. Use  since  to achieve the same thing.  Examples  results = changes(db; include_docs=true, since=0)\nfiltered = changes(db; doc_ids=[ 25806e48920b4a35b3c9d9f23c16c821 ,  644464774951c32fad7243ac8c9745ad ])  API reference  source  #  Couchzilla.changes_streaming     Function .  changes_streaming(db::Database;\n  doc_ids = [],\n  conflicts = false,\n  descending = false,\n  include_docs = false,\n  attachments = false,\n  att_encoding_info = false,\n  limit = 0,\n  since = 0)  Query the CouchDB changes feed, line by line. This is a co-routine.  Note that the last item produced will always be the CouchDB  last_seq   entry.  This is a co-routine. Note that the CouchDB parameter  last-event-id  is  not supported. Use  since  to achieve the same thing.  Examples  for ch in @task changes_streaming(db, limit=1)\n  println(ch)\nend\n\nDict(\n   seq = 1-g1...gm- ,\n   changes = [Dict( rev = 1-24213171b98945a2ed3578c926eb3651 )], \n   id = 37f11227ef384458b01e4afc7eed7194 \n)\nDict(\n   pending = 213,\n   last_seq = 1-g1...gm- \n)  API reference  source  #  Couchzilla.revs_diff     Function .  revs_diff{T :AbstractString}(db::Database; data::Dict{T, Vector{T}} = Dict())  revs_diff  is a component of the CouchDB replication algorithm.  Given set of ids and revs, it will return a potentially empty subset of ids and revs from this list which the remote end doesn't have.  Dict(\n     190f721ca3411be7aa9477db5f948bbb  =  [\n         3-bb72a7682290f94a985f7afac8b27137 ,\n         4-10265e5a26d807a3cfa459cf1a82ef2e ,\n         5-067a00dff5e02add41819138abb3284d \n    ]\n)  Returns  The returned structure is a  Dict  where the keys are the  id s of any documents where missing  rev s are found. An example:  Dict(\n   e1132d11a43933948cb46c5e72e13659  =  Dict(\n     missing  =  [ 2-1f0e2f0d841ba6b7e3d735b870ebeb8c ],\n     possible_ancestors  =  [ 1-efda16b0115e5fcf2cfd065faee674fc ]\n  )\n)  API reference  source  #  Couchzilla.bulk_get     Function .  bulk_get{T :AbstractString}(db::Database; data::Vector{Dict{T, T}} = [])  bulk_get  is used as part of an optimisation of the CouchDB replication algorithm in  recent versions, allowing the replicator to request many documents with full ancestral information in a singe HTTP request.  It is supported in CouchDB  = 2.0 (Cloudant \"DBNext\"), and also suported by PouchDB.  The  data  parameter is a list of  Dict s with keys  id  and  rev .  Examples  result = revs_diff(db; data = [\n  Dict(\n     id   =   f6b40e2fdc017e7e4ec4fa88ae3a4950 , \n     rev  =   2-1f0e2f0d841ba6b7e3d735b870ebeb8c \n  ),\n  Dict(\n     id   =   2f8b7921cbcfde79fb2ff8079cada273 , \n     rev  =   1-6c3ef2ba29b6631a01ce00f80b5b4ad3 \n  )    \n])  Returns  The response format is convoluted, and seemingly undocumented for both CouchDB and Cloudant at the time of writing.  results : [\n{\n   id :  1c43dd76fee5036c0cb360648301a710 ,\n   docs : [\n    {\n       ok : { ..doc body here...\n\n        }\n      }\n    }\n  ]\n},  Reference  source", 
            "title": "Replication"
        }, 
        {
            "location": "/#geospatial", 
            "text": "#  Couchzilla.geo_index     Function .  result = geo_index(db::Database, ddoc::AbstractString, name::AbstractString, index::AbstractString)  Create a geospatial index.  The  index  parameter is a string containing an index function in Javascript.   Examples  result = geo_index(db,  geodd ,  geoidx , \n   function(doc){if(doc.geometry doc.geometry.coordinates){st_index(doc.geometry);}} \n)  Returns  Returns a  Dict(...)  from the CouchDB response, of the type  Dict(\n   ok   =  true, \n   rev  =   1-b950984b19bb1b8bb43513c9d5b235bc ,\n   id   =   _design/geodd \n)  API reference  source  #  Couchzilla.geo_indexinfo     Function .  result = geo_indexinfo(db::Database, ddoc::AbstractString, name::AbstractString)  Retrieve stats for a geospatial index.  Examples  result = geo_indexinfo(db,  geodd ,  geoidx )  Returns  Returns a  Dict(...)  from the CouchDB response, of the type  Dict(\n   name  =   _design/geodd/geoidx ,\n   geo_index  =  Dict(\n     doc_count  =  269,\n     disk_size  =  33416,\n     data_size  =  26974\n  )\n)  API reference  source  #  Couchzilla.geo_query     Function .  geo_query(db::Database, ddoc::AbstractString, name::AbstractString;\n  lat::Float64    = -360.0,\n  lon::Float64    = -360.0,\n  rangex::Float64 = 0.0,\n  rangey::Float64 = 0.0,\n  radius::Float64 = 0.0,\n  bbox::Vector{Float64}  = Vector{Float64}(),\n  relation::AbstractString =  intersects ,\n  nearest = false,\n  bookmark::AbstractString =  ,\n  format::AbstractString =  view , \n  skip = 0,\n  limit = 0,\n  stale = false,\n  g::AbstractString =  )  Query a geospatial index. This quickly becomes complicated. See the references below.   The \"g\" parameter is a string representing a  Well Known Text  object ( WKT ). It can be used to describe various geometries, such as lines and polygons. Currently supported  geometric objects are   point  linestring  polygon  multipoint  multilinestring  multipolygon  geometrycollection   Geo queries can be configured to return its results in a number of different formats using the  format  parameter. The accepted values are:   legacy  geojson  view (default)  application/vnd.geo+json   The  relation  parameter follows the  DE-9IM  spec for geometric relationships. Acceptable values are:   contains  contains_properly  covered_by  covers  crosses  disjoint  intersects (default)  overlaps  touches  within   Examples  Radial query  result = geo_query(geodb,  geodd ,  geoidx ;\n  lat    = 42.357963,\n  lon    = -71.063991,\n  radius = 10000.0,\n  limit  = 200)  Polygon query   result = geo_query(geodb,  geodd ,  geoidx ;\n  g= POLYGON ((-71.0537124 42.3681995 0,-71.054399 42.3675178 0,-71.0522962 42.3667409 0,-71.051631 42.3659324 0,-71.051631 42.3621431 0,-71.0502148 42.3618577 0,-71.0505152 42.3660275 0,-71.0511589 42.3670263 0,-71.0537124 42.3681995 0)) )  API reference  source", 
            "title": "Geospatial"
        }, 
        {
            "location": "/#auth", 
            "text": "#  Couchzilla.get_permissions     Function .  data = get_permissions(db::Database)  Fetch all current permissions. Note: this is Cloudant-specific.  API reference  source  #  Couchzilla.set_permissions     Function .  result = set_permissions(db::Database, current::Dict=Dict{AbstractString, Any}(); key= , roles=[])  Modify permissions. Note: this is Cloudant-specific.  API reference  source  #  Couchzilla.make_api_key     Function .  data = make_api_key(client::Client)  Generate a new API key. Note: this is Cloudant-specific.  Note also that API keys take a long time to propagate around a cluster. It's unsafe to rely on a newly created key to be immediately available. The reason for this is that Cloudant keeps its auth-related documents centrally, and replicate out to all clusters.   API reference  source  #  Couchzilla.delete_api_key     Function .  result = delete_api_key(db::Database, key::AbstractString)  Remove an existing API key. Note: this is Cloudant-specific. This is implemented via  set_permissions() .  API reference  source", 
            "title": "Auth"
        }, 
        {
            "location": "/#utility-stuff", 
            "text": "#  Couchzilla.retry_settings!     Method .  retry_settings!(;enabled=false, max_retries=5, delay_ms=10)  Set parameters for retrying requests failed with a 429: Too Many Requests. This is Cloudant-specific, but safe to leave enabled if using CouchDB, as the error will never be encountered.  Failed requests are retried after a growing interval according to  sleep((tries * delay_ms + rand(1:10))/1000.0)  until  tries  exceed  max_retries  or the request succeeds.  Note: it is not sufficient to rely on this behaviour on a rate-limited Cloudant cluster, as persistently hitting the limits can only be fixed by moving to higher reserved  throughput capacity. For this reason this is disabled by default.  source  #  Couchzilla.retry_settings     Function .  retry_settings()  Return the current retry settings.  source  #  Couchzilla.relax     Function .  relax(fun, url_string; cookies=nothing, query=Dict(), headers=Dict())  Makes an HTTP request with the relevant cookies and query strings and deserialises the response, assumed to be json.  Cloudant implements request throttling based on reerved throughput capacity. Hitting a  capacity limit will return a 429 error (Too many requests). This is Cloudant-specific.  This function can retry on 429 if this behaviour is enabled. See  retry_settings() .  source  #  Couchzilla.endpoint     Function .  endpoint(uri::URI, path::AbstractString)  Appends a path string to the URI, returning as a string.  source", 
            "title": "Utility stuff"
        }
    ]
}